# 0 - 1 BFS

## 1. 개념

> 가중치가 0과 1로만 이루어져 있는 그래프에서 최단 경로를 찾고자 할 때 유용하게 사용 가능한 BFS

단, 문제에 따라서 본인이 직접 0-1로 문제를 구조화시킨 다음에 0-1 BFS를 적용시켜 풀 수도 있다.

### 1) 성능

`O(V + E)`

0-1 BFS는 다익스트라 알고리즘을 최적화 한 것과 유사하다고 볼 수 있다.

다익스트라 알고리즘이 O(ElogE) 또는 `O(ElogV)`인데 0-1 BFS는 `O(V + E)`로 선형 시간으로 문제를 해결할 수 있다.

<br>

### 2) 동작

0-1 BFS는 가장 앞/뒤에 요소를 넣거나 뺄 수 있어야 하므로 `덱(deque)`을 통해서만 구현할 수 있다. 

![image](https://github.com/user-attachments/assets/5ef1d13e-30f3-4a99-b31d-458f8d92e1d5)

```
1. 덱의 front에서 노드를 하나 꺼낸다.
2. 꺼낸 노드와 연결된 인접 노드를 확인한다.
3. 현재 노드까지의 비용 + 해당 노드로 가는 가중치 < 해당 노드까지의 비용인 경우 비용을 갱신해준다.
3-1. 만약 가중치가 1일 경우 덱의 back에 삽입한다.
3-2. 만약 가중치가 0일 경우 덱의 front에 삽입한다.
4. 덱이 비어있을 때까지 이를 반복한다.
```

※ 3번 조건에서 비용이 낮은 경우 갱신한다고 했는데, 매우 중요하다. 일반 BFS와 달리 항상 처음 방문했을 때 최단거리임이 보장되지 않는다.

- A → (1) → B → (0) → C
- A → (0) → C → (0) → B

와 같은 경로가 있다고 할 때 A → B 방문시 boolean 배열로 true를 체크해주면 더 작은 가중치를 가지는 경로로 B를 방문하지 못하게 되기 때문에 최단거리 비용 테이블을 사용해야 한다.

<br>

### 3) 증명

O(V + E)의 증명

- 비용이 작은 경로를 덱의 맨 앞에 삽입하여 우선 탐색하게 되므로 특정 간선을 2번 이상 지나가는 경우는 존재하지 않는다.
  - O(E)
- 마찬가지로 동일한 간선을 2번 이상 지나가지 않으므로, 모든 정점도 2번 이상 경유하는 경우가 존재하지 않는다. 따라서 덱의 크기가 최대 `|V|`로 유지된다.
  - O(V)

결론적으로 두 시간 복잡도를 합한 결과 `O(V + E)`이다.

<br>

## 4) 동작 예시

- 제일 처음 시작 노드는 A이다. (노드에 붙여진 알파벳 간의 우선순위는 없다고 가정한다.)

![image](https://user-images.githubusercontent.com/93081720/235352592-dd568cc8-22b1-4997-ab09-59b98152fecf.png)

- A의 인접 노드인 B, D, F, G를 탐색한다.
  - B, D는 간선의 가중치가 1이므로 덱의 맨 뒤에 삽입한다.
  - F, G는 간선의 가중치가 0이므로 덱의 맨 앞에 삽입한다.

![image](https://user-images.githubusercontent.com/93081720/235352604-5d2b9c48-a465-4194-952c-708486361b90.png)

- 덱의 맨 앞에 있는 F를 뽑은 다음, 인접 노드를 확인한다.
  - A는 가중치가 0이지만 이미 방문했으므로 무시한다.
  - D는 가중치가 1이므로 F를 통해서 D로 가면 총 거리가 2이므로 최단 거리가 아니기 때문에 무시한다.
  - 아직 방문하지 않은 노드인 H를 방문한다. 가중치가 1이므로 덱의 맨 뒤에 삽입한다.

![image](https://user-images.githubusercontent.com/93081720/235352626-5f948129-dba8-449c-9c86-6d1c117e2973.png)

- 덱의 맨 앞에 있는 G를 뽑은 다음, 인접 노드를 확인한다.
  - A는 가중치가 0이지만 이미 방문했으므로 무시한다.
  - 아직 방문하지 않은 노드인 I를 방문한다. 가중치가 1이므로 덱의 맨 뒤에 삽입한다.

![image](https://user-images.githubusercontent.com/93081720/235352636-11753617-d169-4934-ad48-3b3602f9bdcf.png)

- 덱의 맨 앞에 있는 B를 뽑은 다음, 인접 노드를 확인한다.
  - 아직 방문하지 않은 노드인 C를 방문한다. 가중치가 0이므로 덱의 맨 앞에 삽입한다.
  - A와 D는 이미 방문한 노드이므로 무시한다.

![image](https://user-images.githubusercontent.com/93081720/235352710-ad37b003-2275-4482-816c-a843ba07240c.png)

덱의 맨 앞에 있는 C를 뽑은 다음, 인접 노드를 확인한다.

- 아직 방문하지 않은 노드인 E를 방문한다. 가중치가 0이므로 덱의 맨 앞에 삽입한다.
- B는 이미 방문한 노드이므로 무시한다.
- I는 C를 통해 방문하게 될 경우, 거리가 2가 되므로 최단 거리가 아니기 때문에 무시한다.

![image](https://user-images.githubusercontent.com/93081720/235352729-d06fb40b-b55f-4f1c-86af-a2a718bb8d0e.png)

덱의 맨 앞에 있는 E를 뽑은 다음, 인접 노드를 확인한다.

- D는 가중치가 0이지만, E를 통해서 간다 하더라도 총 거리가 1이기 때문에 이미 최단 거리이므로 무시한다.
- H는 E를 통해 방문하게 될 경우, 거리가 2가 되므로 최단 거리가 아니기 때문에 무시한다.
- C는 이미 방문한 노드이므로 무시한다.

![image](https://user-images.githubusercontent.com/93081720/235352741-9c4324a3-8b57-4777-8d3a-20c883ce6d19.png)

덱의 맨 앞에 있는 D를 뽑은 다음, 인접 노드를 확인한다.

- 인접한 모든 노드를 이미 최단 거리로 방문했으므로 무시한다.

![image](https://user-images.githubusercontent.com/93081720/235352746-03cdca25-e127-438b-9a16-a8321af6bc18.png)

덱의 맨 앞에 있는 H를 뽑은 다음, 인접 노드를 확인한다.

- I는 가중치가 0이지만, H를 통해서 간다 하더라도 총 거리가 1이기 때문에 이미 최단 거리이므로 무시한다.
- 나머지 인접한 모든 노드를 이미 최단 거리로 방문했으므로 무시한다.

![image](https://user-images.githubusercontent.com/93081720/235352760-e4aa0484-03c0-4417-b787-29c2fd6b8008.png)

덱의 맨 앞에 있는 I를 뽑은 다음, 인접 노드를 확인한다.

- 인접한 모든 노드를 이미 최단 거리로 방문했으므로 무시한다.

![image](https://user-images.githubusercontent.com/93081720/235352781-9f6b64cd-c9a3-4c4a-9c82-c1c052dc8667.png)

0-1 BFS 완성

![image](https://user-images.githubusercontent.com/93081720/235352824-9497f00e-a654-4b2e-bf2b-3d77d620f38c.png)
