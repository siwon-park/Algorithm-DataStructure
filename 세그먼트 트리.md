# 세그먼트 트리(Segment Tree)

## 1. 정의

`구간에 대한 정보를 보관`하고 있는 트리 형태의 자료 구조

<br>

## 2. 설명

전체 구간이 `[1, N]`이라고 할 때, 즉 `N개의 구간`이 있을 때 이를 `포화 이진 트리`로 만들어서 재귀적으로 호출하여 원하는 구간에 대한 정보를 빠르게 가져오거나, 빠른 시간 안에 구간의 정보를 갱신할 수 있다.

|                 구간 [1, N]을 구성하는 트리                  |                        세그먼트 트리                         |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/06b0c8d7-2b55-41f3-b940-bf3e6e80ffea) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/10db7425-cb09-4cb6-9e77-4d2dfa13b966) |

위와 같이 이진 트리는 아니지만 N개의 구간 정보를 갖고 있는 트리가 있을 때, 이를 오른쪽과 같이 포화 이진 트리로 구간을 나눠서 재구성할 수 있다. (포화 이진 트리로 만들기 위해 구간을 늘림)

### How?

그림을 보면 알겠지만, 원래는 `[1, 3]`와 같이 기존 트리에는 있던 구간이었지만 포화 이진 트리로 변환하면서 해당 구간이 사라졌음을 알 수 있다.

이제 우리는 `기록되어 있지 않은 구간(=하나의 노드로 표현할 수 없는 구간)`에 대해서 값을 구해야 한다.

구간 `[1, 3]`은  `[1, 1]`, `[2, 2]`, `[3, 3]`의 합으로 계산할 수 있다. 그런데 진짜 그렇게 계산해야 할까?

그렇지 않다. 구간 `[1, 3]`을 포화 이진 트리 상에서 나눠진 구간을 잘 보면 구간 `[1, 2]`와 구간 `[3, 3]`이다.

그런데 구간 `[1, 2]`는 구간 `[1, 1]`, `[2, 2]`로 나눌 필요 없이 이미 포화 이진 트리 상에 존재하는 구간 `[1, 2]`의 값을 사용하면 된다.

즉, 이미 정해진 구간에 저장된 값 + 추가적으로 구해야 할 노드의 값을 재귀적으로 호출하여 계산하는 것이 바로 세그먼트 트리의 핵심이다.

특정 정해진 구간들은 값이 이미 계산되어 저장된 상태이기 때문에 빠르게 값을 호출할 수 있는 것이다.

<br>

## 성능

### O(logN)

구간의 정보를 계산하거나, 업데이트 할 때 모두 O(logN)의 시간이 걸린다.

#### 이유

값을 갱신하고자 한다면, 리프 노드에서 출발하여 부모 노드를 갱신하고, 또 그 부모 노드의 부모 노드를 갱신하는 재귀적 호출을 계속하는데, 이진 트리의 높이가 logN이므로 O(logN)이 걸린다.

합이나 곱을 구하는 연산에서도 마찬가지로 트리의 높이만큼 재귀적 호출을 반복하므로 O(logN)의 시간이 소모된다.

<br>

## 구현

크게 구현해야 할 함수는 다음과 같음

- 생성자(세그먼트 트리의 크기와 배열을 생성)
- 초기에 세그먼트 트리를 구성하는 함수
- 구간에 대한 정보를 반환하는 함수
- 구간에 대한 정보를 갱신하는 함수