# 세그먼트 트리(Segment Tree)

## 1. 정의

`구간에 대한 정보를 보관`하고 있는 트리 형태의 자료 구조

<br>

## 2. 설명

전체 구간이 `[1, N]`이라고 할 때, 즉 `N개의 구간`이 있을 때 이를 `포화 이진 트리`로 만들어서 재귀적으로 호출하여 원하는 구간에 대한 정보를 빠르게 가져오거나, 빠른 시간 안에 구간의 정보를 갱신할 수 있다.

|                 구간 [1, N]을 구성하는 트리                  |                        세그먼트 트리                         |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/06b0c8d7-2b55-41f3-b940-bf3e6e80ffea) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/10db7425-cb09-4cb6-9e77-4d2dfa13b966) |

위와 같이 이진 트리는 아니지만 N개의 구간 정보를 갖고 있는 트리가 있을 때, 이를 오른쪽과 같이 포화 이진 트리로 구간을 나눠서 재구성할 수 있다. (포화 이진 트리로 만들기 위해 구간을 늘림)

### How?

그림을 보면 알겠지만, 원래는 `[1, 3]`와 같이 기존 트리에는 있던 구간이었지만 포화 이진 트리로 변환하면서 해당 구간이 사라졌음을 알 수 있다.

이제 우리는 `기록되어 있지 않은 구간(=하나의 노드로 표현할 수 없는 구간)`에 대해서 값을 구해야 한다.

구간 `[1, 3]`은  `[1, 1]`, `[2, 2]`, `[3, 3]`의 합으로 계산할 수 있다. 그런데 진짜 그렇게 계산해야 할까?

그렇지 않다. 구간 `[1, 3]`을 포화 이진 트리 상에서 나눠진 구간을 잘 보면 구간 `[1, 2]`와 구간 `[3, 3]`이다.

그런데 구간 `[1, 2]`는 구간 `[1, 1]`, `[2, 2]`로 나눌 필요 없이 이미 포화 이진 트리 상에 존재하는 구간 `[1, 2]`의 값을 사용하면 된다.

즉, 이미 정해진 구간에 저장된 값 + 추가적으로 구해야 할 노드의 값을 재귀적으로 호출하여 계산하는 것이 바로 세그먼트 트리의 핵심이다.

특정 정해진 구간들은 값이 이미 계산되어 저장된 상태이기 때문에 빠르게 값을 호출할 수 있는 것이다.

<br>

## 3. 성능

> O(logN)

구간의 정보를 계산하거나, 업데이트 할 때 모두 O(logN)의 시간이 걸린다.

#### (1) 이유

값을 갱신하고자 한다면, 리프 노드에서 출발하여 부모 노드를 갱신하고, 또 그 부모 노드의 부모 노드를 갱신하는 재귀적 호출을 계속하는데, 이진 트리의 높이가 logN이므로 O(logN)이 걸린다.

합이나 곱을 구하는 연산에서도 마찬가지로 트리의 높이만큼 재귀적 호출을 반복하므로 O(logN)의 시간이 소모된다.

<br>

## 4. 구현

크게 구현해야 할 함수는 다음과 같음

- 생성자(세그먼트 트리의 크기와 배열을 생성)
- 초기에 세그먼트 트리를 구성하는 함수
- 구간에 대한 정보를 반환하는 함수
- 구간에 대한 정보를 갱신하는 함수

<br>

## 5. 문제 유형

### 1) 교차하는 선분의 개수 구하기

"나보다 뒤에 나오는데, 끝점은 나보다 앞에 있는 선분"의 개수를 구하는 문제.

현재 선분의 끝점 인덱스 + 1 ~ N까지 누적하여 계산한다.

- 원리
  - 선분들이 주어지는데, 각 선분은 (시작점, 끝점) 형태로 표현된다.
  - 시작점을 기준으로 오름차순 정렬한다. (모든 선분에 대해서 start[i] < start[j]를 만족함)
  - 선분1과 선분2가 서로 교차하기 위해서는 선분1의 끝점이 선분2의 끝점보다 뒤에 있어야 함. (end[i] > end[j])
  - 즉, 교차하는 선분의 개수는 내 뒤에 오는 선분들 중 끝 점이 나보다 작은 것들의 개수를 구하면 됨. (혹은 나보다 앞에 있는 선분 중에 끝점이 나보다 큰 선분의 개수를 구하면 됨)
- 동작 과정
  - 구간 [끝점 + 1, N]의 합을 계산하여 누적 => "끝점이 나보다 큰 선분의 개수"
  - 현재 나의 끝점의 위치에 +1을 하여 값을 업데이트 (+1을 한다는 것은 현재 끝점에 선분을 긋는다고 보면 됨)

