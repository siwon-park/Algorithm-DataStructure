# 정렬(Sort)

> 버블 정렬, 삽입 정렬, 선택 정렬, 병합 정렬, 퀵 정렬에 대한 정리

<br>

## 1. 버블 정렬 (Bubble Sort)

`인접한 두 원소를 매번 비교`하여 필요할 경우 위치를 교환하는 방식으로 동작하는 정렬 알고리즘

정렬하는 과정에서 인접한 두 원소를 교환하는 모양이 거품처럼 올라왔다가 내려가는 것 같아서 버블 정렬임

### 1) 동작 방식

오름차순 정렬

1. 배열을 순회하면서 현재 원소와 다음 원소를 비교
2. 현재 원소가 다음 원소보다 크면 두 원소를 교환
3. 배열의 끝에 도달할 때까지 1, 2과정을 반복
4. 한 번의 순회가 끝나면 가장 큰 원소가 리스트의 맨 끝으로 이동함

위 과정을 반복한다.



### 2) 성능

#### (1) 시간 복잡도

|  최악  |  평균  | 최선 |
| :----: | :----: | :--: |
| O(N^2) | O(N^2) | O(N) |

- 단, 여기서 말하는 최선은 이미 정렬된 상태 + break 구문을 사용해서 쓸데없는 반복을 피한 경우에 해당
  - 1회의 패턴 검사에서 swap이 한 번도 일어나지 않았다면 이미 정렬된 상태이기 때문에 break(하단 코드 참조)


#### (2) 공간 복잡도

O(N)



### 3) 코드

```java
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        boolean swap = false; // 최적화를 위한 값
        for (int j = 0; j < n - i - 1; j++) { // 뒤에서부터 한 칸씩 줄임
            if (arr[j] > arr[j + 1]) {
                // 교환
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                swap = true;
            }
        }
        if (!swap) break;
    }
}
```

<br>

## 2. 삽입 정렬 (Insertion Sort)

주어진 리스트를 순회하면서 현재 위치의 원소를 `정렬된 부분과 비교`하여 적절한 위치에 `삽입`하는 방식으로 동작하는 정렬 방식

![image](https://github.com/siwon-park/Algorithm-DataStructure/assets/93081720/0a378c42-6517-4d14-b1f5-679e3a16d015)

### ※ 선택 정렬과의 차이점

- `삽입 정렬은 현재 원소를 정렬된 부분에 삽입하는 방식`인 반면,
  - 선택 정렬은 현재 위치에 들어갈 적절한 원소를 현재 위치보다 큰 곳에서 찾아서 선택하여 이동시키는 방식으로 동작한다.
  - 따라서 삽입 정렬은 정렬된 곳과 비교하기 때문에 최적화가 가능한 반면, 선택 정렬은 정렬되지 않은 곳과 비교하기 때문에 최적화가 불가능하다.
- 삽입 정렬의 성능은 비교 횟수나 데이터의 크기에 영향을 받는다. 왜냐하면 `정렬된 곳과 비교를 하기 때문이다. 따라서 정렬되어 있을 수록 성능이 좋다.`
  - 반면 선택 정렬은 항상 최솟값 혹은 최댓값을 선택해야 하기 때문에 그 비교 횟수는 고정적이기 때문에 거의 동일한 성능을 보여준다.

### 1) 동작 방식

오름차순 정렬

1. 두 번째 원소(인덱스 1)부터 시작한다.
2. 현재 인덱스보다 작으면서 현재 값보다 큰 값을 만날 때까지 왼쪽으로 이동한다.
   - 이는 현재 인덱스보다 작은 요소들은 정렬되어 있음을 가정하기 때문이다.
3. 적절한 위치를 찾으면 현재 원소를 해당 위치에 삽입한다.
   - 다음 원소에 대해 위 과정을 반복하는데, 새로운 원소가 삽입되면서 점차 정렬된 부분이 늘어난다.

위 과정을 반복한다.

### 2) 성능

#### (1) 시간 복잡도

|  최악  |  평균  | 최선 |
| :----: | :----: | :--: |
| O(N^2) | O(N^2) | O(N) |

- 단, 여기서 말하는 최선은 이미 정렬된 상태 + break 구문을 사용해서 쓸데없는 반복을 피한 경우에 해당

#### (2) 공간 복잡도

O(N)

### 3) 코드

```python
def insert_sort(arr: list) -> list:
    n = len(arr)
    for i in range(1, n):
        for j in range(i, 0, -1):  # 자신 이하의 인덱스 ~ 0까지 비교 탐색
            if arr[j] < arr[j - 1]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j]
            else:  # 정렬된 부분(앞)과 비교하기 때문에 break가 가능
                break
    return arr
```

```java
void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
        int val = arr[i];
        int j = i - 1;

        // 현재 원소보다 큰 원소를 만날 때까지 왼쪽으로 이동
        while (j >= 0 && arr[j] > val) {
            // 교환하는 것처럼 보이지만 실제로는 적절한 위치를 찾아 한 칸씩 계속 밀어내는 것임
            arr[j + 1] = arr[j]; 
            j = j - 1;
        }

        // 적절한 위치에 현재 원소 삽입
        arr[j + 1] = val;
    }
}
```

<br>

## 3. 선택 정렬 (Selection Sort)

주어진 리스트에서 `최솟값(또는 최댓값)을 찾아(선택)` 현재 원소와 교환하는 방식으로 동작하는 정렬 알고리즘.

일반적인 구현 방식은 최솟값 혹은 최댓값이 위치한 인덱스를 찾고, 이를 활용해서 현재 인덱스에 위치한 숫자와 바꾸는 방식이다.

![image](https://github.com/siwon-park/Algorithm-DataStructure/assets/93081720/8ac2e869-cf36-40b0-898c-8dd0b523f9e1)

### 1) 동작 방식

오름차순 정렬

1. 현재 인덱스를 최솟값이라고 가정한다.
2. 현재 인덱스보다 큰 위치이면서 현재값보다 작은 최솟값을 찾는다.
   - 현재 인덱스보다 큰 위치를 탐색하는 이유는 이전까지는 정렬되어 있다고 가정하기 때문이다. (물론 실제로도 그렇다.)
3. 찾은 최솟값의 인덱스와 현재 인덱스에 있는 숫자를 서로 교환한다.

위 과정을 반복한다.

### 2) 성능

#### (1) 시간 복잡도

|  최악  |  평균  |  최선  |
| :----: | :----: | :----: |
| O(N^2) | O(N^2) | O(N^2) |

- 선택 정렬은 현재 인덱스보다 큰 인덱스에서 적절한 원소를 찾기 때문에 최적화 불가

#### (2) 공간 복잡도

O(N)

### 3) 코드

```java
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i; // 최솟값의 인덱스를 찾기
        for (int j = i + 1; j < n; j++) { // 자기보다 큰 인덱스에서 찾기 때문에 최적화 어려움
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }

        // 최솟값과 현재 위치의 원소 교체
        int tmp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = tmp;
    }
}
```

<br>

## 4. 병합 정렬 (Merge Sort)

분할 정복과 재귀 호출을 통한 정렬 알고리즘

계속해서 이분할하고, 대소 관계를 비교하여 재배치한 다음에 원래 크기의 배열로 병합하는 과정을 거친다.

나눈 배열을 병합하는 과정에서 정렬된 데이터를 저장할 임시 배열이 필요하여 추가적인 메모리가 사용된다.

### 1) 동작 방식

#### (1) 분할(sort)

현재 배열의 시작 인덱스와 끝 인덱스를 기준으로 이분할한다.

#### (2) 병합(merge)

왼쪽, 오른쪽 비교를 통해 작은 것부터 임시 배열에 복사하고

왼쪽의 남은 부분부터 임시 배열에 복사한 다음, 오른쪽의 남은 부분을 임시 배열에 차례대로 복사한다.

그 후 최종적으로 임시 배열의 데이터를 원본 배열로 옮긴다.

### 2) 성능

#### (1) 시간 복잡도

|   최악   |   평균   |   최선   |
| :------: | :------: | :------: |
| O(NlogN) | O(NlogN) | O(NlogN) |

#### (2) 공간 복잡도

O(N)

### 3) 코드

```java
int[] arr = new int[n];; // 원본 배열
int[] tmp = new int[n]; // 임시 배열

void sort(int start, int end) {
    if (start >= end) return;
    int mid = (start + end) / 2;
    sort(start, mid);
    sort(mid + 1, end);
    merge(start, end);
}

void merge(int start, int end) {
    int mid = (start + end) / 2;
    int i = start; // 왼쪽으로 나눴을 때의 가장 작은 인덱스
    int j = mid + 1; // 오른쪽으로 나눴을 때의 가장 작은 인덱스
    int k = 0; // 임시 배열의 인덱스

    // 왼쪽, 오른쪽 비교해서 작은 것부터 임시 배열에 복사
    while (i <= mid && j <= end) {
        if (arr[i] <= arr[j]) tmp[k++] = arr[i++];
        else tmp[k++] = arr[j++];
    }

    // 왼쪽의 남은 부분을 임시 배열에 복사
    while (i <= mid) tmp[k++] = arr[i++];

    // 오른쪽의 남은 부분을 임시 배열에 복사
    while (j <= end) tmp[k++] = arr[j++];

    // 임시 배열의 데이터를 원본 배열로 옮김
    for (i = start; i <= end; i++) arr[i] = tmp[i - start];
}
```

<br>

## 5. 퀵 정렬 (Quick Sort)

병합 정렬과 마찬가지로 재귀 호출을 통해 정렬을 하는 알고리즘이지만, `pivot(기준점)`을 정하여 왼쪽(left)와 오른쪽(right)를 분리하여 재귀 호출을 반복한다.

### 1) 동작 방식

1. pivot(기준점)을 정한다.
   - 보통 배열의 첫번째나 중앙에 위치한 값을 선택함.
2. 피벗보다 작은 데이터를 왼쪽(left)에 담는다.
3. 피벗보다 큰 데이터를 오른쪽(right)에 담는다.
4. 왼쪽에 대해 1 ~ 3과정을 수행할 수 있는 재귀 함수를 호출한다.
5. 오른쪽에 대해 1 ~ 3과정을 수행할 수 있는 재귀 함수를 호출한다.
6. 왼쪽 재귀 결과 + pivot + 오른쪽 재귀 결과를 합친 것이 정렬된 배열이다.

### 2) 성능

#### (1) 시간 복잡도

|  최악  |   평균   |   최선   |
| :----: | :------: | :------: |
| O(N^2) | O(NlogN) | O(NlogN) |

#### (2) 공간 복잡도

O(N)

### 3) 코드

```python
def quick_sort(data: list) -> list:
    if len(data) <= 1:  # 원소가 1개만 남으면 더이상 호출할 필요 없음(종료)
        return data
    left, right = [], []
    pivot = data[0]  # pivot(기준점)을 배열의 첫번째 원소로 설정
    # 피벗 이후의 데이터에 대해 피벗보다 작은 데이터는 왼쪽(left) 배열에 담고, 큰 데이터는 오른쪽(right) 데이터에 담음
    left = [num for num in data[1:] if pivot > num]
    right = [num for num in data[1:] if pivot <= num]
    return quick_sort(left) + [pivot] + quick_sort(right)
```

### 4) 퀵 정렬을 더 많이 쓰는 이유?

대부분의 언어의 기본 정렬 알고리즘에서 병합 정렬보다 퀵 정렬을 더 많이 사용하는 이유는 뭘까?

퀵 정렬은 대부분의 컴퓨터 아키텍처에서 효율적으로 동작하도록 설계되어 있다. 메모리 참조가 지역화되어 있어 CPU의 캐시 히트율이 높아지기 때문

#### (1) 지역성(Locality) 때문

> 지역성(Locality)란 CPU가 짧은 시간 범위 내에서 일정 구간의 메모리 영역을 반복적으로 엑세스하는 경향을 말한다.

메모리 내의 정보를 균일하게 엑세스 하는 것이 아니라 짧은 시간 내에 특정 부분을 집중적으로 참조하는 특성이 바로 지역성이다.

지역성이 왜 중요할까? 바로 이는 `캐시(Cache)`의 개념과 밀접한 관련이 있다.

CPU는 `현재 프로세스의 실행 패턴을 보고 가까운 미래에 프로세스의 코드와 데이터를 합리적으로 사용할 수 있도록 예측`할 수 있다. 이 코드와 데이터를 캐시에 저장해둔다면 성능적으로 이점을 얻을 수 있다.

지역성 정도가 높은 데이터를 캐시에 올려서 사용하면 더 빠르게 데이터를 사용할 수 있는 반면(`캐시 히트`), 지역성이 낮은 데이터를 캐시에 올린다면 의미가 없어진다.(`캐시 미스`)

따라서 정렬하려고 하는 데이터들이 다른 페이지로 이동하는 것 없이, 현재 자신의 페이지에서 계속 있는 것이 성능적인 측면에서 더 좋다.

- 캐시가 없는 다른 페이지로 이동하게 되면 캐시 히트율이 떨어지게 되고 결국에는 물리적 메모리(Physical Memory)로 접근해야 하기 때문에 상대적으로 시간이 더 많이 걸린다.
- 정렬하려는 데이터들이 자신의 페이지에 계속 있는다면, 캐시를 통해 반복적으로 쉽게 접근할 수 있어 시간이 덜 걸린다.

|                    병합 정렬(Merge Sort)                     |                     퀵 정렬(Quick Sort)                      |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![병합정렬](https://github.com/siwon-park/Algorithm-DataStructure/assets/93081720/113aac22-9b94-41ca-81b8-4e5285d87414) | ![퀵 정렬](https://github.com/siwon-park/Algorithm-DataStructure/assets/93081720/264e00dc-abbe-4b6a-8df2-9fe93944f95a) |

병합 정렬을 보면 왼쪽에서 오른쪽으로, 그리고 좌우를 왔다갔다하면서 정렬하고 동작 과정 상 그림이 한 번에 확 바뀌는 부분이 잦다.

반면에 퀵 정렬은 한눈에 보기에도 병합 정렬에 비해 그러한 경우가 적다. 즉, 각 데이터들이 넓은 범위 내에서 움직이지 않고 좁은 범위 내에서 움직이고 있음을 알 수 있다.

한 개의 사각형이 캐시라고 한다면, 캐시 히트 비율이 퀵 정렬이 병합 정렬보다 훨씬 높은 것이다.

따라서 퀵 정렬이 최악의 경우 성능이 O(N^2)일지라도 그러한 경우는 정말 극히 드물기 때문에 병합 정렬보다 성능상으로 이점이 있기 때문에 더 많이 사용하는 것이다.

<br>

## 6. 그 외 정렬 (Other sorts)

그 외에 잘 알려져있는 정렬 알고리즘들

### 1)  힙 정렬 (Heap Sort)

시간 복잡도: O(NlogN)

<br>

### 2) 계수 정렬 (Counting Sort)

시간 복잡도: O(N + K)

<br>