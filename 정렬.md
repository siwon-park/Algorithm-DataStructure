# 정렬(Sort)

> 버블 정렬, 삽입 정렬, 선택 정렬, 병합 정렬, 퀵 정렬에 대한 정리

<br>

## 1. 버블 정렬 (Bubble Sort)

`인접한 두 원소를 매번 비교`하여 필요할 경우 위치를 교환하는 방식으로 동작하는 정렬 알고리즘

정렬하는 과정에서 인접한 두 원소를 교환하는 모양이 거품처럼 올라왔다가 내려가는 것 같아서 버블 정렬임

### 1) 동작 방식

오름차순 정렬

1. 배열을 순회하면서 현재 원소와 다음 원소를 비교
2. 현재 원소가 다음 원소보다 크면 두 원소를 교환
3. 배열의 끝에 도달할 때까지 1, 2과정을 반복
4. 한 번의 순회가 끝나면 가장 큰 원소가 리스트의 맨 끝으로 이동함

위 과정을 반복한다.



### 2) 성능

#### (1) 시간 복잡도

|  최악  |  평균  | 최선 |
| :----: | :----: | :--: |
| O(N^2) | O(N^2) | O(N) |

- 단, 여기서 말하는 최선은 이미 정렬된 상태 + break 구문을 사용해서 쓸데없는 반복을 피한 경우에 해당
  - 1회의 패턴 검사에서 swap이 한 번도 일어나지 않았다면 이미 정렬된 상태이기 때문에 break(하단 코드 참조)


#### (2) 공간 복잡도

O(N)



### 3) 코드

```java
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        boolean swap = false; // 최적화를 위한 값
        for (int j = 0; j < n - i - 1; j++) { // 뒤에서부터 한 칸씩 줄임
            if (arr[j] > arr[j + 1]) {
                // 교환
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                swap = true;
            }
        }
        if (!swap) break;
    }
}
```

<br>

## 2. 삽입 정렬 (Insertion Sort)

주어진 리스트를 순회하면서 현재 위치의 원소를 `정렬된 부분과 비교`하여 적절한 위치에 `삽입`하는 방식으로 동작하는 정렬 방식

### ※ 선택 정렬과의 차이점

- `삽입 정렬은 현재 원소를 정렬된 부분에 삽입하는 방식`인 반면,
  - 선택 정렬은 현재 위치에 들어갈 적절한 원소를 찾아서 선택하여 이동시키는 방식으로 동작한다.
- 삽입 정렬의 성능은 비교 횟수나 데이터의 크기에 영향을 받는다. 왜냐하면 `정렬된 곳과 비교를 하기 때문이다. 따라서 정렬되어 있을 수록 성능이 좋다.`
  - 반면 선택 정렬은 항상 최솟값 혹은 최댓값을 선택해야 하기 때문에 그 비교 횟수는 고정적이기 때문에 거의 동일한 성능을 보여준다.

### 1) 동작 방식

오름차순 정렬

1. 두 번째 원소(인덱스 1)부터 시작한다.
2. 현재 인덱스보다 작으면서 현재 값보다 큰 값을 만날 때까지 왼쪽으로 이동한다.
   - 이는 현재 인덱스보다 작은 요소들은 정렬되어 있음을 가정하기 때문이다.
3. 적절한 위치를 찾으면 현재 원소를 해당 위치에 삽입한다.
   - 다음 원소에 대해 위 과정을 반복하는데, 새로운 원소가 삽입되면서 점차 정렬된 부분이 늘어난다.

위 과정을 반복한다.

### 2) 성능

#### (1) 시간 복잡도

|  최악  |  평균  | 최선 |
| :----: | :----: | :--: |
| O(N^2) | O(N^2) | O(N) |

- 단, 여기서 말하는 최선은 이미 정렬된 상태 + break 구문을 사용해서 쓸데없는 반복을 피한 경우에 해당

#### (2) 공간 복잡도

O(N)

### 3) 코드

```python
def insert_sort(arr: list) -> list:
    n = len(arr)
    for i in range(1, n):
        for j in range(i, 0, -1):  # 자신 이하의 인덱스 ~ 0까지 비교 탐색
            if arr[j] < arr[j - 1]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j]
            else:  # 정렬된 부분(앞)과 비교하기 때문에 break가 가능
                break
    return arr
```

```java
void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
        int val = arr[i];
        int j = i - 1;

        // 현재 원소보다 큰 원소를 만날 때까지 왼쪽으로 이동
        while (j >= 0 && arr[j] > val) {
            // 교환하는 것처럼 보이지만 실제로는 적절한 위치를 찾아 한 칸씩 계속 밀어내는 것임
            arr[j + 1] = arr[j]; 
            j = j - 1;
        }

        // 적절한 위치에 현재 원소 삽입
        arr[j + 1] = val;
    }
}
```

<br>

## 3. 선택 정렬 (Selection Sort)

주어진 리스트에서 `최솟값(또는 최댓값)을 찾아(선택)` 현재 원소와 교환하는 방식으로 동작하는 정렬 알고리즘.

일반적인 구현 방식은 최솟값 혹은 최댓값이 위치한 인덱스를 찾고, 이를 활용해서 현재 인덱스에 위치한 숫자와 바꾸는 방식이다.

### 1) 동작 방식

오름차순 정렬

1. 현재 인덱스를 최소 인덱스라고 가정한다.
2. 현재 인덱스보다 큰 위치이면서 현재값보다 작은 최솟값을 찾는다.
   - 현재 인덱스보다 큰 위치를 탐색하는 이유는 이전까지는 정렬되어 있다고 가정하기 때문이다. (물론 실제로도 그렇다.)
3. 찾은 최솟값의 인덱스와 현재 인덱스에 있는 숫자를 서로 교환한다.

위 과정을 반복한다.

### 2) 성능

#### (1) 시간 복잡도

|  최악  |  평균  |  최선  |
| :----: | :----: | :----: |
| O(N^2) | O(N^2) | O(N^2) |

- 선택 정렬은 현재 인덱스보다 큰 인덱스에서 적절한 원소를 찾기 때문에 최적화 불가

#### (2) 공간 복잡도

O(N)

### 3) 코드

```java
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i; // 최솟값의 인덱스를 찾기
        for (int j = i + 1; j < n; j++) { // 자기보다 큰 인덱스에서 찾기 때문에 최적화 어려움
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }

        // 최솟값과 현재 위치의 원소 교체
        int tmp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = tmp;
    }
}
```

<br>

## 4. 병합 정렬 (Merge Sort)

분할 정복과 재귀 호출을 통한 정렬 알고리즘

계속해서 이분할하고, 대소 관계를 비교하여 재배치한 다음에 원래 크기의 배열로 병합하는 과정을 거친다.

나눈 배열을 병합하는 과정에서 정렬된 데이터를 저장할 임시 배열이 필요하여 추가적인 메모리가 사용된다.

### 1) 동작 방식

#### (1) 분할(sort)

현재 배열의 시작 인덱스와 끝 인덱스를 기준으로 이분할한다.

#### (2) 병합(merge)

왼쪽, 오른쪽 비교를 통해 작은 것부터 임시 배열에 복사하고

왼쪽의 남은 부분부터 임시 배열에 복사한 다음, 오른쪽의 남은 부분을 임시 배열에 차례대로 복사한다.

그 후 최종적으로 임시 배열의 데이터를 원본 배열로 옮긴다.

### 2) 성능

#### (1) 시간 복잡도

|   최악   |   평균   |   최선   |
| :------: | :------: | :------: |
| O(NlogN) | O(NlogN) | O(NlogN) |

#### (2) 공간 복잡도

O(N)

### 3) 코드

```java
int[] arr = new int[n];; // 원본 배열
int[] tmp = new int[n]; // 임시 배열

void sort(int start, int end) {
    if (start >= end) return;
    int mid = (start + end) / 2;
    sort(start, mid);
    sort(mid + 1, end);
    merge(start, end);
}

void merge(int start, int end) {
    int mid = (start + end) / 2;
    int i = start; // 왼쪽으로 나눴을 때의 가장 작은 인덱스
    int j = mid + 1; // 오른쪽으로 나눴을 때의 가장 작은 인덱스
    int k = 0; // 임시 배열의 인덱스

    // 왼쪽, 오른쪽 비교해서 작은 것부터 임시 배열에 복사
    while (i <= mid && j <= end) {
        if (arr[i] <= arr[j]) tmp[k++] = arr[i++];
        else tmp[k++] = arr[j++];
    }

    // 왼쪽의 남은 부분을 임시 배열에 복사
    while (i <= mid) tmp[k++] = arr[i++];

    // 오른쪽의 남은 부분을 임시 배열에 복사
    while (j <= end) tmp[k++] = arr[j++];

    // 임시 배열의 데이터를 원본 배열로 옮김
    for (i = start; i <= end; i++) arr[i] = tmp[i - start];
}
```

<br>

## 5. 퀵 정렬 (Quick Sort)

병합 정렬과 마찬가지로 재귀 호출을 통해 정렬을 하는 알고리즘이지만, `pivot(기준점)`을 정하여 왼쪽(left)와 오른쪽(right)를 분리하여 재귀 호출을 반복한다.

### 1) 동작 방식

1. pivot(기준점)을 정한다.
   - 보통 배열의 첫번째나 중앙에 위치한 값을 선택함.
2. 피벗보다 작은 데이터를 왼쪽(left)에 담는다.
3. 피벗보다 큰 데이터를 오른쪽(right)에 담는다.
4. 왼쪽에 대해 1 ~ 3과정을 수행할 수 있는 재귀 함수를 호출한다.
5. 오른쪽에 대해 1 ~ 3과정을 수행할 수 있는 재귀 함수를 호출한다.
6. 왼쪽 재귀 결과 + pivot + 오른쪽 재귀 결과를 합친 것이 정렬된 배열이다.

### 2) 성능

#### (1) 시간 복잡도

|  최악  |   평균   |   최선   |
| :----: | :------: | :------: |
| O(N^2) | O(NlogN) | O(NlogN) |

#### (2) 공간 복잡도

O(N)

### 3) 코드

```python
def quick_sort(data: list) -> list:
    if len(data) <= 1:  # 원소가 1개만 남으면 더이상 호출할 필요 없음(종료)
        return data
    left, right = [], []
    pivot = data[0]  # pivot(기준점)을 배열의 첫번째 원소로 설정
    # 피벗 이후의 데이터에 대해 피벗보다 작은 데이터는 왼쪽(left) 배열에 담고, 큰 데이터는 오른쪽(right) 데이터에 담음
    left = [num for num in data[1:] if pivot > num]
    right = [num for num in data[1:] if pivot <= num]
    return quick_sort(left) + [pivot] + quick_sort(right)
```

<br>

## 6. 그 외 정렬 (Other sorts)

그 외에 잘 알려져있는 정렬 알고리즘들

### 1)  힙 정렬 (Heap Sort)

시간 복잡도: O(NlogN)

<br>

### 2) 계수 정렬 (Counting Sort)

시간 복잡도: O(N + K)

<br>