# 정렬(Sort)

정렬에 대한 정리

<br>

## 1. 버블 정렬 (Bubble Sort)

`인접한 두 원소를 매번 비교`하여 필요할 경우 위치를 교환하는 방식으로 동작하는 정렬 알고리즘

정렬하는 과정에서 인접한 두 원소를 교환하는 모양이 거품처럼 올라왔다가 내려가는 것 같아서 버블 정렬임

### 1) 동작 방식

오름차순 정렬

1. 배열을 순회하면서 현재 원소와 다음 원소를 비교
2. 현재 원소가 다음 원소보다 크면 두 원소를 교환
3. 배열의 끝에 도달할 때까지 1, 2과정을 반복
4. 한 번의 순회가 끝나면 가장 큰 원소가 리스트의 맨 끝으로 이동함

위 과정을 반복한다.

### 2) 성능

시간 복잡도: O(N^2)

### 3) 코드

```java
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 교환
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

<br>

## 2. 선택 정렬 (Selection Sort)

주어진 리스트에서 `최솟값(또는 최댓값)을 찾아(선택)` 현재 원소와 교환하는 방식으로 동작하는 정렬 알고리즘.

일반적인 구현 방식은 최솟값 혹은 최댓값이 위치한 인덱스를 찾고, 이를 활용해서 현재 인덱스에 위치한 숫자와 바꾸는 방식이다.

### 1) 동작 방식

오름차순 정렬

1. 현재 인덱스를 최소 인덱스라고 가정한다.
2. 현재 인덱스보다 큰 위치이면서 현재값보다 작은 최솟값을 찾는다.
   - 현재 인덱스보다 큰 위치를 탐색하는 이유는 이전까지는 정렬되어 있다고 가정하기 때문이다. (물론 실제로도 그렇다.)
3. 찾은 최솟값의 인덱스와 현재 인덱스에 있는 숫자를 서로 교환한다.

위 과정을 반복한다.

### 2) 성능

시간 복잡도: O(N^2)

### 3) 코드

```java
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i; // 최솟값의 인덱스를 찾기
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }

        // 최솟값과 현재 위치의 원소 교체
        int tmp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = tmp;
    }
}
```

<br>

## 3. 삽입 정렬 (Insertion Sort)

주어진 리스트를 순회하면서 현재 위치의 원소를 `정렬된 부분과 비교`하여 적절한 위치에 `삽입`하는 방식으로 동작하는 정렬 방식

### ※ 선택 정렬과의 차이점

- 삽입 정렬은 현재 원소를 정렬된 부분에 삽입하는 방식인 반면,
  - 선택 정렬은 현재 위치에 들어갈 적절한 원소를 찾아서 선택하여 이동시키는 방식으로 동작한다.
- 삽입 정렬의 성능은 비교 횟수나 데이터의 크기에 영향을 받는다. 왜냐하면 정렬된 곳과 비교를 하기 때문이다. 따라서 정렬되어 있을 수록 성능이 좋다.
  - 반면 선택 정렬은 항상 최솟값 혹은 최댓값을 선택해야 하기 때문에 그 비교 횟수는 고정적이기 때문에 거의 동일한 성능을 보여준다.

### 1) 동작 방식

오름차순 정렬

1. 두 번째 원소(인덱스 1)부터 시작한다.
2. 현재 인덱스보다 작으면서 현재 값보다 큰 값을 만날 때까지 왼쪽으로 이동한다.
   - 이는 현재 인덱스보다 작은 요소들은 정렬되어 있음을 가정하기 때문이다.
3. 적절한 위치를 찾으면 현재 원소를 해당 위치에 삽입한다.
   - 다음 원소에 대해 위 과정을 반복하는데, 새로운 원소가 삽입되면서 점차 정렬된 부분이 늘어난다.

위 과정을 반복한다.

### 2) 성능

시간 복잡도: O(N^2)

### 3) 코드

```java
void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
        int val = arr[i];
        int j = i - 1;

        // 현재 원소보다 큰 원소를 만날 때까지 왼쪽으로 이동
        while (j >= 0 && arr[j] > val) {
            // 교환하는 것처럼 보이지만 실제로는 적절한 위치를 찾아 한 칸씩 계속 밀어내는 것임
            arr[j + 1] = arr[j]; 
            j = j - 1;
        }

        // 적절한 위치에 현재 원소 삽입
        arr[j + 1] = val;
    }
}
```

<br>

## 4. 병합 정렬 (Merge Sort)

시간 복잡도: O(NlogN)

<br>

## 5. 퀵 정렬 (Quick Sort)

시간 복잡도: O(NlogN)

<br>

## 6. 그 외 정렬 (Other sorts)

그 외에 잘 알려져있는 정렬 알고리즘들

### 1)  힙 정렬 (Heap Sort)

시간 복잡도: O(NlogN)

<br>

### 2) 계수 정렬 (Counting Sort)

시간 복잡도: O(N + K)

<br>