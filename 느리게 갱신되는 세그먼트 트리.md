# 느리게 갱신되는 세그먼트 트리

> 레이지 프로퍼게이션(Lazy Propagation)

## 개념

일반적인 세그먼트 트리를 통해서는 구간에 대한 연산 결과 정보를 빠르게 가져올 수 있었다.

또한 특정 배열의 인덱스 값을 변경하더라도 `O(logN)`의 시간으로 변경 후, 구간의 변경된 결과값까지 가져올 수 있었다.

하지만 만약에 특정 인덱스의 값을 변경하는 것이 아니라, `특정 구간의 값을 일괄 변경해야 하는 경우`에는 어떻게 할까?

일반적인 세그먼트 트리의 `update`연산을 통해서 이를 계산하려 한다면, 구하고자 하는 구간의 수(M)만큼의 쿼리를 하나씩 날려야 하기 때문에  `O(MlogN)`의 시간이 걸리게 되어 `for`구문 한 번 순회하는 것보다 오래 걸릴 수 밖에 없다.

하지만 **레이지 프로퍼게이션(Lazy Propagation)**을 활용한다면 이와 같이 `특정 구간 [a, b]에 값 c를 동시에 더한다`라는 연산을 매우 빠르게 처리할 수 있다.

어떻게 이게 가능하게 할 수 있을까?

바로, **Lazy 배열**의 존재를 통해서 가능하게 만들 수 있다.

Lazy 배열이 의미하는 바는 `해당 영역에 얼마만큼 연산할 계획이 있다`라는 것을 알려주기 위한 배열이다.

이 Lazy 배열을 활용해서

- 만약 특정 구간에 처리해야 할 일이 있다면, 즉 해당 구간의 lazy 배열에 값이 있다면,
  - `해당 구간의 수 x lazy 배열의 값`만큼 구간 연산의 결과를 변화시켜준다. (구간 합을 구하는 세그먼트 트리인 경우)
  - 그리고, 만약 `해당 구간이 리프 노드가 아닐 경우에는 자식에게 lazy 배열의 값을 전달`시켜준다.
  - 마지막으로 해당 구간에서 처리해야 할 일은 끝났으므로, `구간의 lazy 배열의 값은 0으로 초기화` 시켜준다.
- 처리해야 할 일이 없다면, 일반적인 세그먼트 트리의 연산처럼 처리하면 된다.

### 왜 빠른가?

일단 일반적인 세그먼트 트리를 사용할 경우에 왜 느린지는 설명할 수 있었다.

그렇다면 이게 왜 빠른가에 대한 의문이 생길 수도 있다.

바로 매번 lazy배열에 대한 처리를 하는 것이 아니라 `해당 구간이 참조될 때만 lazy배열에 있는 것을 처리`하기 때문에,

굳이 모든 구간에 일정 값을 전부 다 업데이트한 다음에 계산이 완료된 값을 가져오는 것이 아니라 필요한 값만 그 때만 한 번에 계산해서 가져오고 각 구간에 대한 업데이트 값은 나중에 계산하기 때문이다.

즉, 참조되는 구간만 업데이트되는 셈이다. 만약 찾고자 하는 구간 `[L, R]`이 있고 세그먼트 트리의 구간인 `s, e`가 정확히 구간 `[L, R]`에 포함된다면 `s`와 `e`의 하위 구간에 대해서는 나중에 직접 참조할 때만 업데이트 되는 것이다.

- 정확히 포함된다는 의미는 `L <= s && e <= R`을 만족한다는 의미이다.
- 예를 들어 하위 구간인 구간 `[s, s]`의 값은 `[s, s]를 직접 참조할 때만 업데이트 된다.`
- 만약 정확히 포함되지 않고 일부만 포함된다면 구간 `[s, s]` 혹은 구간 `[s, e]`에 존재하는 단말 노드가 업데이트 될 수도 있다.

<br>

## 과정

다음과 같이 구성된 세그먼트 트리가 있다고 하자

만약 구간 `'[3, 7]에 2를 더하라'`라는 연산이 주어졌을 때, 어떻게 될까?

![image](https://user-images.githubusercontent.com/93081720/235339145-250c6813-00c8-4127-9cd1-f43706a2ce9c.png)

먼저 노드를 다음과 같이 나눌 수 있다.

변경되는 구간에 구간에 해당하는 숫자가 어느 하나라도 포함된다면 값이 변경되어야 하는 것은 맞지만 처리를 다르게 가져가야 한다.

- 구간의 일부만 포함되는 노드의 경우, 즉 서브 트리의 구간 중 일부는 포함되고 일부는 포함되지 않는 경우
  - 일반적인 세그먼트 트리의 연산 결과를 호출하는 것처럼 문제를 해결하면 된다.
- 서브 트리의 구간이 변경하려는 구간에 모두 포함되는 경우
  - 관리하는 서브 트리의 개수만큼(정확히는 서브 트리가 관리하는 리프 노드의 수) * 변경하려는 값만큼 값을 변경시켜준다.
  - 그 후, 자식에게 lazy 연산할 수 있도록 값을 내려준 다음에 현재 구간의 lazy 값은 0으로 만든다.
- 즉, 어쨌든 결과적으로 세그먼트 트리를 가지고 구간의 연산 결과를 호출할 때, 매번 lazy 배열을 확인하는 과정이 추가되어 확인 결과에 따른 추가적인 연산이 들어가게 되는 것이다.

![image](https://user-images.githubusercontent.com/93081720/235339172-9b3b2eb6-0bbd-4829-81a6-b42973bac907.png)