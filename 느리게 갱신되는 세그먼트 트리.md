# 느리게 갱신되는 세그먼트 트리

> 레이지 프로퍼게이션(Lazy Propagation)

일반적인 세그먼트 트리를 통해서는 구간에 대한 연산 결과 정보를 빠르게 가져올 수 있었다.

또한 특정 배열의 인덱스 값을 변경하더라도 `O(logN)`의 시간으로 변경 후, 구간의 변경된 결과값까지 가져올 수 있었다.

하지만 만약에 특정 인덱스의 값을 변경하는 것이 아니라, `특정 구간의 값을 일괄 변경해야 하는 경우`에는 어떻게 할까?

일반적인 세그먼트 트리의 `update`연산을 통해서 이를 계산하려 한다면, `O(MlogN)`의 시간이 걸리게 되어 `for`구문 한 번 순회하는 것보다 오래 걸리게 됩니다.

하지만 **레이지 프로퍼게이션(Lazy Propagation)**을 활용한다면 이와 같이 `특정 구간 [a, b]에 값 c를 동시에 더한다`라는 연산을 매우 빠르게 처리할 수 있습니다.

어떻게 이게 가능하게 할 수 있을까?

바로, **Lazy 배열**의 존재를 통해서 가능하게 만들 수 있습니다.

`해당 영역에 얼마만큼 연산할 계획이 있다`라는 것을 알려주기 위한 배열입니다.

앞으로 이 Lazy 배열을 활용해서

- 만약 특정 구간에 처리해야 할 일이 있다면, 즉 해당 구간의 lazy 배열에 값이 있다면
  - `해당 구간의 수 x lazy 배열의 값`만큼 구간 연산의 결과를 변화시켜준다
  - 그리고, 만약 `해당 구간이 리프 노드가 아닐 경우에는 자식에게 lazy 배열의 값을 전달`시켜준다
  - 마지막으로 해당 구간에서 처리해야 할 일은 끝났으므로, `구간의 lazy 배열의 값은 0으로 초기화` 시켜준다
- 처리해야 할 일이 없다면, 일반적인 세그먼트 트리의 연산처럼 처리하면 된다.

<br>

## 과정

다음과 같이 구성된 세그먼트 트리가 있다고 하자

만약 구간 `'[3, 7]에 2를 더하라'`라는 연산이 주어졌을 때, 어떻게 될까?

![image](https://user-images.githubusercontent.com/93081720/235339145-250c6813-00c8-4127-9cd1-f43706a2ce9c.png)

먼저 노드를 다음과 같이 나눌 수 있다.

변경되는 구간에 구간에 해당하는 숫자가 어느 하나라도 포함된다면 값이 변경되어야 하는 것은 맞지만 처리를 다르게 가져가야 한다.

- 구간의 일부만 포함되는 노드의 경우, 즉 서브 트리의 구간 중 일부는 포함되고 일부는 포함되지 않는 경우
  - 일반적인 세그먼트 트리의 연산 결과를 호출하는 것처럼 문제를 해결하면 된다.
- 서브 트리의 구간이 변경하려는 구간에 모두 포함되는 경우
  - 관리하는 서브 트리의 개수만큼(정확히는 서브 트리가 관리하는 리프 노드의 수) * 변경하려는 값만큼 값을 변경시켜준다.
  - 그 후, 자식에게 lazy 연산할 수 있도록 값을 내려준 다음에 현재 구간의 lazy 값은 0으로 만든다.
- 즉, 어쨌든 결과적으로 세그먼트 트리를 가지고 구간의 연산 결과를 호출할 때, 매번 lazy 배열을 확인하는 과정이 추가되어 확인 결과에 따른 추가적인 연산이 들어가게 되는 것이다.

![image](https://user-images.githubusercontent.com/93081720/235339172-9b3b2eb6-0bbd-4829-81a6-b42973bac907.png)