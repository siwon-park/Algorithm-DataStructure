# 04_Tree(트리)

## 1. 정의

비선형 구조, 계층형 자료 구조, 한 개 이상의 노드로 이루어진 유한 집합, 원소들 간 `1:N`관계인 자료 구조

상위 원소에서 하위 원소로 내려가면서 확장되는 나무(tree) 모양의 구조

※ 그래프는 N:N관계, 트리는 1:N관계이므로, 그래프가 더 포괄적임. 따라서 트리를 `무방향` 연결 그래프라고 함

<br>

## 2. 특징

### 1) 연결 컴포넌트(Connected Component)

트리에 속한 임의의 정점 u, v사이에 유일한 경로가 반드시 하나만 존재함(사이클이 없기 때문)

<br>

### 2) 논-사이클(Non-Cycle)

트리는 **사이클(Cycle)이 없다**.

따라서 트리를 순회할 때 굳이 중복을 방지하기 위해 방문 표시를 하지 않아도 된다.

단, 이는 부모 → 자식으로만 간다고 보장되었을 경우에 해당하고, 그렇지 않고 자식 → 부모로 이동하는 경우가 생기면 방문 표시를 해줘야 할 수도 있다.

<br>

### 3) 서브 트리(Sub Tree)

트리는 분리될 수 있으며, 이 **분리된 집합 또한 하나의 트리이며, 서브 트리**라고 한다.

<br>

### 4) 기타 특징

**노드가 하나만 있더라도 트리**라고 부를 수 있다.

트리로 포함관계를 표현할 수 있으며, 괄호를 표현할 수도 있다.

<br>

## 3. 구조 및 용어

### 1) 서브트리(Sub Tree)

트리에서 분리된 집합 또한 하나의 트리이다.

<br>

### 2) 노드(Node, Vertex)

트리의 원소, 트리의 노드 수는 간선의 수(E) +1개이다. (`V = E + 1`)

<br>

#### 루트 노드(root)

 트리의 시작점이 되는 노드. 부모 노드가 없음

#### 리프 노드(단말 노드, Leaf)

트리의 제일 끝단에 있는 노드. 자식 노드가 없음

#### 형제 노드(Sibilings)

동일한 노드를 부모로 하는 자식 노드들(부모가 같은 노드들)

#### 조상 노드(ancestor)

한 노드에서 간선을 따라 루트 노드까지 이르는 경로에 있는 노드들

#### 자손 노드(descendant)

서브 트리에 있는 하위 노드들

<br>

### 3) 간선(Edge)

노드를 연결하는 선, 트리의 노드가 `V`개일 때 간선의 수는`V - 1`개다.

<br>

### 4) 차수(Indegree)

노드에 연결된 자식 노드의 수
- 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값을 말함
- 진입 차수와는 다른 개념. 진입 차수는 들어오는 간선의 수를 말함

<br>

### 5) 높이

루트 노드에서 어떤 한 노드에 이르는 간선 수, 노드의 레벨 또는 계층
- 루트 노드의 높이는 0
- 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값

※ 단, 트리의 높이에 대해서 완벽하게 정의된 것이 없으며, 루트의 높이를 `0`으로 보느냐, `1`로 보느냐 차이가 존재한다.

<br>

## 4. 트리의 순회(Traversal)

>  중복없이 체계적으로(빠짐없이), 트리의 각 노드를 방문하는 것

`깊이 우선 탐색(DFS)`으로 순회하며, **반드시 오른쪽 자식보다 왼쪽 자식을 먼저 방문**한다.

사실 상 `트리의 순회는 모든 정점을 3번씩 방문하는 셈`이다. (처음 들어오면서 한번, 왼쪽 아래로 나갔다가 다시 들어오면서 1번, 오른쪽 아래로 나갔다가 다시 들어오면서 1번)

트리는 실제로 `무방향 그래프`이지만, `탐색을 위해 부모에서 자식 방향으로 유향 형태로 저장`한다.

V : 루트 노드 / L : 왼쪽 서브 트리 / R : 오른쪽 서브 트리

순회 결과를 카운트해서 루트 노드 수는 1개, 왼쪽 서브 트리의 노드 수는 l개, 오른쪽 서브 트리의 노드 수는 r개이며, 합산하면 1+l+r이고,  재귀적으로 계산하면 모든 노드의 수를 구할 수 있음

```python
def subtree_size(v):
    if v == 0:
        return 0
    l = subtree_size(L[v])
    r = subtree_size(R[v])
    return l+r+1 # 모든 노드의 개수
```

<br>

### 1. 전위 순회(PreOrder) 

> 루트(V) → 왼쪽(L) → 오른쪽(R), VLR

![image](https://user-images.githubusercontent.com/93081720/158604456-076a2915-c5b5-4e6f-88e3-49c4a8dfdf45.png)

#### 순회 방법 

1. 현재 노드를 방문 처리함
2. 현재 노드의 왼쪽 서브 트리로 이동함
3. 현재 노드의 오른쪽 서브 트리로 이동

![image](https://user-images.githubusercontent.com/93081720/158597757-063003da-4a06-42e8-af6f-5989c32bc7a0.png)

```python 
preorder(1) # 1 2 4 8 9 5 10 3 6 7
```

<br>

### 2) 중위 순회(InOrder)

> 왼쪽(L) → 루트(V) → 오른쪽(R), LVR

![image](https://user-images.githubusercontent.com/93081720/158604737-7a17b84e-f197-43ff-95f3-52eed76ceecd.png)

#### 순회 방법

1. 현재 노드의 왼쪽 서브 트리로 이동함
2. 현재 노드를 방문 처리함
3. 현재 노드의 오른쪽 서브 트리로 이동

![image](https://user-images.githubusercontent.com/93081720/158597845-52bab2d0-55c1-4482-985e-b1a1a694ed57.png)

```python
inorder(1) # 8 4 9 2 10 5 1 6 3 7
```

<br>

### 3) 후위 순회(PostOrder)

> 왼쪽(L) → 오른쪽(R) → 루트(V), LRV

![image](https://user-images.githubusercontent.com/93081720/158604908-f37647e3-00a9-4391-b09e-4226ac5b4dec.png)

#### 순회 방법

1. 현재 노드의 왼쪽 서브 트리로 이동함
2. 현재 노드의 오른쪽 서브 트리로 이동
3. 현재 노드를 방문 처리함

![image](https://user-images.githubusercontent.com/93081720/158597951-90774e06-c355-42d0-95e7-65210c144e70.png)

```python
postorder(1) # 8 9 4 10 5 2 6 7 3 1
```

<br>

### 4) 다른 순회 결과를 통한 순회 조회하기(재귀)

> 루트와 왼쪽 서브 트리, 오른쪽 서브 트리의 위치를 이용해 재귀적으로 호출하여 순회의 결과를 찾을 수 있다.

- `전위 순회와 중위 순회`를 알고 있을 때, `후위 순회`를 알 수 있다. (전중후)
- `후위 순회와 중위 순회`를 알고 있을 때, `전위 순회`를 알 수 있다. (후중전)
- 그러나, 전위 순회와 후위 순회를 알고 있다고 해서 올바른 중위 순회를 알아 낼 수 있음을 보장하지 않는다.

![image](https://user-images.githubusercontent.com/93081720/230100133-680d2385-5379-4a0d-b29e-c1ca734ce9a1.png)

<br>

#### 전위 순회, 중위 순회를 통해 후위 순회 찾기 (전중후)

![image](https://user-images.githubusercontent.com/93081720/230115303-d9d8f702-870a-430d-9013-7bea10d74614.png)

![image](https://user-images.githubusercontent.com/93081720/230112430-551b1f37-4120-4b38-968e-85f0b0f05b87.png)

#### 후위 순회, 중위 순회를 통해 전위 순회 찾기 (후중전)

![image](https://user-images.githubusercontent.com/93081720/230116441-0a92c542-8b00-4494-a0b5-02cbfa50c20a.png)

![image](https://user-images.githubusercontent.com/93081720/230112339-b346ce4d-f8be-496f-b973-f7f0d404f0f6.png)

<br>

## 5. 종류

트리의 종류는 매우 다양하며, 대표적으로는

- 이진 트리
  - 포화 이진 트리
  - 완전 이진 트리
  - 편향 이진 트리

등이 있다.

또한 트리는 다양한 자료 구조의 근간이 되는 핵심 자료 구조이다.
