# 백트랙킹(BackTracking)

> 다시 돌아가 추적함(Back + Tracking)

백트랙킹이란 Back(뒤, 다시) + Tracking(추적)을 합친 말로, 다시 돌아가 추적함 또는 뒤 돌아가서 추적한다는 의미를 가지고 있다.

왜 다시 돌아가서 추적하는가? 알고리즘 문제를 풀다보면 원상태에서 출발해서 특정 행동을 하는 것도 있지만, `특정 상태에서 어떤 행동을 해야할 수도 있다.`

가장 대표적인 경우를 예로 들면 `순열`을 찾는 경우이다. 순열의 경우 특정 상태에서 출발해서 다음에 올 숫자를 찾는다.

물론 브루트포스로도 순열을 찾을 수 있다. 그러면 백트랙킹과 브루트포스의 차이점은 무엇일까?

- 브루트포스로 순열을 찾으려면 찾고자 하는 순열의 크기만큼 N번 for 순회해야 한다.
  - N번 하드 코딩하거나 재귀 호출을 하면 된다.
- 그러나, 브루트포스는 말 그대로 `무차별`적이기 때문에 모든 경우에 대해서 탐색하게 된다.
  - 즉, 낭비적으로 N ^ N번 탐색하게 된다.
- 하지만 백트랙킹을 사용하면 특정 상태에서 탐색을 시작할 수도 있기 때문에 최적화가 가능해진다.
  - 물론 브루트포스가 무조건적으로 최적화가 절대 불가능하다는 말은 아니다.

<br>

## 백트랙킹 구현의 핵심

백트랙킹 구현의 핵심은 `상태 공간 트리`를 그리는 것이다.

상태 공간 트리란 `트리 형태로 상태를 표현한 것`을 말한다.

- 예) [1, 2, 3]에서 2개를 선택하는 상태 공간 트리

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/cb3efbc0-bf41-4f93-b6e8-3e8662d9d126)

백트랙킹을 구현하다 보면 여러 상태 케이스가 존재한다.

- 선택지가 `N개`인 경우(선택하지 않아도 되는 경우)
  - 현재 선택지를 선택하고 넘어간다.
  - 현재 선택지를 선택하지 않고 넘어간다.
- 선택지가 `N개`인 경우(반드시 N개 중 어떤 선택지를 선택해야 함)
  - N번 선택지를 선택하고 넘어간다.

그런데 결국 위 케이스를 보면 본질은 같다. 결국 선택하지 않는 것도 하나의 선택지이기 때문에 어떤 선택지를 고르고 다음으로 넘어가느냐가 핵심이다.

즉, 어떻게 보면 정말 완전 탐색과 같을 수는 있으나 특정 시점에서 원하는 대로 컨트롤하거나 원하는 상태만 가져가게 만들 수 있다는 장점이 있다.

<br>

## 백트랙킹 구현 시 유의 사항

생각보다 백트랙킹을 구현할 때 실수할 수 있는 부분을 비교 설명한다.

위에서 백트랙킹에 존재하는 상태 중 `선택하지 않고 넘어간다`도 있다고 했다.

다음 코드를 예시로 보면, `선택하고 넘어간다`와 `선택하지 않고 넘어간다` 이렇게 2개의 선택지가 있다.

| 최적화 전                                                    | 최적화 후                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/aa03ee74-e314-49de-ab10-8392b0c591d1) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/63abc713-fa5a-48f5-83ec-379ed0dd272a) |

그런데 위 두 코드를 잘 보면, `어떤 선택지를 먼저 호출하느냐`에 따라 코드의 성능이 달라질 수도 있다.

- 최적화 전 코드를 보면, `현재 선택지를 선택하는 것을 먼저 호출`한다.
  - 따라서 선택하지 않음을 이후에 호출하기 위해 `원상 복구 작업이 필요`하다.
- 하지만 최적화 후 코드를 보면 `선택하지 않음을 먼저 호출`하게 되어 아무런 행동도 취하지 않고 다음으로 넘어간 다음에, 호출 종료 이후 현재 선택지를 선택하기 위해 특정 작업을 한다.
  - 어차피 현재 선택지를 선택하는 것을 호출하면 호출 종료 후에는 아무것도 취하지 않기 때문에 `원상 복구 연산이 필요가 없다.`

위 코드의 경우 특정 작업을 하고, 원상 복구하는데 큰 연산이 없지만 만약 추가적인 복잡한 연산 과정이 필요하다면 시간, 공간적으로 성능 상 차이가 발생할 수도 있다.

그래도 물론 이 두 코드의 차이는 아래에 비하면 그렇게 크리티컬하지 않다.

| 최적화 전                                                    | 최적화 후                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/e269e50e-0388-4857-8db3-26be1aecc172) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/63abc713-fa5a-48f5-83ec-379ed0dd272a) |

최적화 전 코드는 매번 for 순회를 하고 있고, 최적화 후 코드는 마지막에만 for 순회를 하고 있다.

만약에 2중 반복문이라면? 효율성은 더 많이 떨어질 것이다.

왜 이런 현상이 발생했는가? `선택하지 않음`을 상태로 고려하지 않았기 때문에 이에 대해서 체크하기 위해 호출 이후 for 반복문을 통해 어떤 작업을 수행한 것이다.

선택하지 않는다고 해서 그 상태를 고려하지 않는 것이 아니다. `선택하지 않음도 분명한 어떤 상태`이다. 게다가 어차피 k값이 증가하기 때문에 선택을 안 한 상태가 반영되어 가는 것이기 때문에 k == N일 때 특정 작업을 수행해도 선택하지 않음에 대한 상태도 충분히 고려가 되는 것이다.
