# 06_Coroutine(코루틴)

<br>

## 00_Why Coroutine?

코루틴의 개념은 비동기 프로그래밍(병렬 프로그래밍)과 밀접한 연관이 있다.

##### ★☆코루틴을 사용하면 CPU와 리소스 낭비를 방지할 수 있어 I/O 처리를 극대화할 수 있다.☆★ 

=> 코루틴은 싱글 스레드에서 대기 시간을 최소화하여 CPU의 활용을 극대화시키는데 그 목적이 있다.

물론, 멀티 스레드를 사용한 작업이 효율이 더 좋을 수도 있겠지만, 멀티 스레드 작업 환경을 구축하는 것은 복잡한 편이고 교착 상태(데드락) 발생 가능성이 존재하는데다가 문맥교환(Context Switching) 비용이 크기 때문에 싱글 스레드에서의 작업이 더 효율적인 경우가 발생하기도 한다.

<br>

## 01_메인 루틴과 서브 루틴

우리가 흔히 아는 프로그래밍의 동작 방식으로, 메인 루틴 함수가 실행되다가 서브 루틴을 호출하고 대기하고, 서브 루틴의 작업이 시작/종료되고 나면 다시 메인 루틴으로 돌아가 함수를 계속 실행하는 동작 방식이다.

이 때, 서브 루틴은 메인 루틴에 종속된 관계이며, 서브 루틴이 끝나면 서브 루틴에 있던 내용들은 전부 사라지게 된다.

<br>
![image](https://user-images.githubusercontent.com/93081720/171644832-6534cebc-baea-49c4-b78d-c3fea35df94c.png)
<br>

## 02_코루틴(Coroutine)

코루틴은 협력(cooperative) + 루틴(routine)을 합친 단어로, 서로 협력하는 루틴이라는 의미를 갖고 있다. 코루틴은 메인-서브 루틴의 동작 방식과 다르게 동작하며, 종속 관계가 아니라 서로 대등한 관계이며 특정 시점에 진입 또는 빠져나오는 것이 가능하다. => 코루틴은 함수의 진입점(entry point)이 여러 개인 함수이다.

아래 예시와 같이, 코루틴 함수가 종료되지 않은 상태에서 메인 루틴으로 돌아가 메인 루틴의 코드를 실행한 뒤, 진행 중이었던 코루틴의 코드로 다시 돌아와 실행하는 것이 가능하다. => 코루틴 함수가 종료되지 않았으므로 코루틴 안에 있던 내용도 그대로 유지된다.

일반 함수는 호출하면 해당 코드를 한번만 실행할 수 있는 반면에, 코루틴은 코드를 여러 번 실행 가능하다.

<br>

![image](https://user-images.githubusercontent.com/93081720/171646041-52188509-825c-4090-80b7-ea610375eae3.png)

<br>

![image](https://user-images.githubusercontent.com/93081720/171647609-15947ba3-162c-48d9-957a-95417745353c.png)

※ `next(코루틴 객체명)`를 통해서 코루틴을 메인 루틴에서 호출할 수 있지만, `코루틴 객체명.send(None)`을 통해서도 코루틴 함수를 호출 가능하다.

<br>

### 01_코루틴의 종류

코루틴은 크게 제너레이터 기반의 코루틴과 네이티브 코루틴으로 구분할 수 있다.

- `yield`를 통해 구현한 코루틴 함수를 제네레이터 기반 코루틴이라고 하고,

- 파이썬의 `asyncio`모듈을 사용해서 `async`키워드와 `await`키워드를 통해 구현한 코루틴을 네이티브 코루틴이라고 한다.



