# 트라이(Trie)

## 개념

> 효율적인 문자열 저장 및 탐색을 위한 자료 구조

여러 문자열을 저장하는 자료 구조로 `레딕스 트리(radix tree)` 또는 `접두사 트리(prefix tree)`라고도 함

`트라이(Trie)`는 다음과 같이 단어를 문자로 쪼개서 하나의 노드로 저장한 다음 트리 형태를 구성해서 저장하는 자료 구조이다.

![image](https://user-images.githubusercontent.com/93081720/235431670-39169675-e95b-4aae-b556-44225fe66529.png)

### 구현

일반적으로 트라이에서는 `삽입`, `검색` 연산을 구현한다. `삭제` 연산도 구현 가능하지만 보통 삭제 연산은 구현하지 않는다고 한다.

- 삽입(`insert`)
  - 루트부터 시작해서 문자열의 길이만큼 순회하여 Map 자료형에 자식 노드를 계속해서 이어 붙이는 구조로 자료 구조를 형성한다.
- 검색(`search` 또는 `contains`)
  - 찾으려는 문자열 길이만큼 트라이의 노드를 순회하다가
    - 아직 탐색 대상 문자열만큼 탐색하지 않았는데 노드가 null이면 `false`
  - 찾으려는 문자열의 길이만큼 순회했는데, 해당 노드가 마지막 글자가 아니라면 `false`
- 삭제(`delete`)
  - 재귀적으로 구현함
  - 삭제할 문자의 끝 노드에 마지막 글자 유무를 `false`로 전환함
  - 그러나 삭제할 문자가 다른 문자의 접두사인 경우 => 즉, 현재 노드가 마지막 글자 표시가 `true`인데, 자식 노드가 있다면?
    - 무작정 삭제하면 다른 단어에도 영향을 끼치기 때문에 적절하지 못함
  - 삭제할 단어(문자)가 유일(unique)하여 다른 문자와 연관이 전혀 없는 경우
    - 관련 모든 노드를 삭제해도 무방
  - 삭제할 단어(문자)가 다른 단어(문자)의 일부일 경우
    - 영향이 가지 않는 곳까지만 삭제

<br>

### 성능

문자열 삽입 및 탐색: `O(M)`

#### 성능 비교

문자열의 최대 길이: `M`, 문자열의 개수: `N`

- 단순 비교 시: 최악의 경우 `O(MN)`
- 이진 탐색 시: 최악의 경우 `O(NMlogN)`
  - 탐색: `O(MlogN)` → 최악의 경우 N개까지 탐색

