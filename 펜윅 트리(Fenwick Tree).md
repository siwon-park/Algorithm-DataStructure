# 펜윅 트리(Fenwick Tree)

> 바이너리 인덱스드 트리(Binary Indexed Tree; BIT)

## 1. 개념

> 세그먼트 트리보다 메모리를 절약하기 위한 방법으로 만들어진 자료 구조

세그먼트 트리가 `이진 트리`형태로 노드를 가진다고 한다면,

펜윅 트리는 `부분적으로 불필요한 정보를 제외`하고 트리를 구성할 수 있다.

| 세그먼트 트리                                                | 펜윅 트리                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image](https://github.com/siwon-park/Algorithm-DataStructure/assets/93081720/c7470f1f-7634-47b6-9ac6-29010e426fbe) | ![image](https://github.com/siwon-park/Algorithm-DataStructure/assets/93081720/d462e246-1c6e-440a-9a4c-0a84f89c2c2f) |

펜윅 트리의 핵심은 구간 합 대신 **부분 합만을 빠르게 계산할 수 있는 자료 구조를 만들어 구간 합을 계산**하는 것이다.

따라서 쿼리 연산 및 업데이트 속도에 있어서는 세그먼트 트리와 동일하지만, 메모리 상으로는 세그먼트 트리보다 작다.

<br>

### 1) 원리

펜윅 트리를 구현하려면, 어떤 수 `X`를 `이진수로 나타냈을 때 등장하는 마지막 1의 위치`를 알아야 한다.

**이진수로 나타냈을 때 마지막 1의 숫자**가 무엇인지 중요하다.

- 3 = 1**1** = 1
- 4 = **1**00 = 4
- 5 = 10**1** = 1
- 6 = 1**1**0 = 2
- 10 = 10**1**0 = 2
- 12 = 1**1**00 = 4
- 16 = **1**0000 = 16

i를 이진수로 표현했을 때 마지막 1이 나타내는 값을 L[i]라 하면 다음 그림과 같은 표가 만들어진다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/1f5ae88e-6443-4828-9829-93b2c8b14028)

이 때, 배열 A에 N개의 수가 담겨있다고 할 경우 `tree[i]`를 **A[i]를 포함하여 앞으로 L[i]개의 합이 저장**되어 있다고 하자. 그러면 이를 그림으로 나타내면 다음과 같다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/def0b72d-455c-4c7d-8cd8-313d0ebe2138)

#### L[i] 쉽게 구하기

`L[i]`를 쉽게 구할 수 있는 방법이 있다. 매번 이진수로 변환해서 마지막 1을 찾고 그 값을 구하기란 번거로운 일이 아닐 수 없다.

`L[i] = i & -i`이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/4db58340-a3aa-4b9a-8926-391ccb4f471a)

그 이유는 다음과 같다.

```
      -num = ~num + 1
       num = 100110101110101100000000000
      ~num = 011001010001010011111111111
      -num = 011001010001010100000000000 = ~num + 1
num & -num = 000000000000000100000000000
```

#### tree[i]

`A = [3, 2, 5, 7, 10, 3, 2, 7, 8, 2, 1, 9, 5, 10, 7, 4]`이라고 할 때, `tree[i]`가 저장하고 있는 값은 다음과 같다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/cbab7874-91f9-4b51-95f5-4073c57a0194)

<br>

## 2. 동작

이제 자료 구조를 완성했다. 어떻게 동작할까?

### 1) 합 구하기

> 구간 5 - 13의 합 구하기

`A[5] + A[6] + ... + A[13]`의 값은 `tree[8] + tree[12] + tree[13] - tree[4]`이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/ece0b9bb-c954-4d5b-983b-f372d74727ca)

<br>

#### 합 구하기의 원리

어떤 구간 합 `A[i] + A[i + 1] + ... + A[j]`는 `A[1] + A[2] + ... + A[j]`에서 `A[1] + A[2] + ... + A[i - 1]`을 뺀 값과 같다.

즉, **구간 합은 부분합들의 합이거나 부분합들의 합에서 다시 부분합을 빼서 구할 수 있다.**

`SUM[i]`를 `1부터 i까지의 합`이라고 정의할 때, 위의 식을 다시 표현하면 `SUM[j] - SUM[i - 1]` = `A[i] + A[i + 1] + ... + A[j]`이다.

따라서 우리는 구간합을 구하기 위해서 `SUM[i]`, `SUM[j]`, `SUM[k]`들을 구하고 이를 활용하여 우리가 원하는 구간 합을 계산하는 것이다. 

- `i`에서 출발하는 화살표를 따라서 가는 방향에 있는 숫자를 더하면서 `SUM[i]`를 구하는 과정을 그림으로 표현하면 다음과 같다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/42995d50-786a-4d11-bed0-168635b9eae5)

<br>

#### 합 구하기의 원리(비트)

> 1이 있는 가장 오른쪽 비트(최하위 비트)가 0으로 바뀌는 과정을 합친 값

`SUM[13]`을 구하는 과정을 자세히 보자

십진수로 `13 → 12 → 8`로 이동하는 것을 볼 수 있고 이를 비트로 표현하면 `1101 → 1100 → 1000`으로 마지막 1의 비트가 0으로 바뀌는 것을 볼 수 있다.

그림으로 표현하면 다음과 같다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/bb8f8054-6680-4cd9-902e-b7e51e555891)

즉, i부터 시작해서 마지막 최하위 비트가 1인 곳의 비트가 0으로 바뀌는 과정을 반복하는 것이다. 이를 식으로 표현하면 다음과 같다.

```java
int sum(int i) {
    int ans = 0;
    while (i > 0) {
        ans += tree[i];
        i -= (i & -i); // i의 마지막 최하위 비트가 1인 곳을 구한 다음에 이를 i에서 뺌 -> i의 최하위 비트가 1인 곳의 비트를 0으로 만듦
    }
    return ans;
}
```

<br>

### 2) 업데이트 연산

> 업데이트하는 구간을 완벽하게 포함하는 구간 합, 부분 합들을 업데이트

업데이트는 더 간단하게 이해할 수 있다.

업데이트하려는 구간을 완벽하게 포함하고 있는 구간에 있는 값들만 갱신시켜주면 된다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/072c3c77-6de5-42d7-9b16-9477106c83dd)

<br>

#### 업데이트 연산의 원리

`i`에서 출발하는 화살표를 따라서 가는 방향에 있는 숫자에 업데이트 할 값 `v`를 반영해주면 된다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/20ab04a1-b9c2-4167-a099-e43e9d200799)

<br>

#### 업데이트 연산의 원리(비트)

> 1이 있는 가장 오른쪽에 있는 비트(최하위 비트)에 비트 1을 더한 구간들에 일정 값을 업데이트

구간 [11, 11]에 값을 업데이트 한다고 하면 업데이트 구간이 `11 → 12 → 16`으로 이동하는 것을 볼 수 있고, 이를 비트로 표현하면 `1011 → 1100 → 10000`으로 최하위 비트가 1인 곳에 비트 1을 더하면서 이동하는 것을 알 수 있다.

그림으로 표현하면 다음과 같다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/441cdcbd-31ba-407b-8346-0a4f417e4bbd)

즉, i부터 시작해서 마지막 최하위 비트가 1인 곳에 비트 1을 더하는 과정을 반복하는 것이다. 이를 식으로 표현하면 다음과 같다.

```java
void update(int i, int v) {
    while (i <= n) { // 구간의 최대 크기가 n이기 때문에 n을 포함해야 함
        tree[i] += v;
        i += (i & -i); // i의 마지막 최하위 비트를 구한 다음에 이를 i에 더 함 -> i의 최하위 비트가 1인 곳에 비트 1을 더함
    }
}
```

<br>

## 3. 비교

[백준 2042번 구간 합 구하기](https://www.acmicpc.net/problem/2042)를 세그먼트 트리와 펜윅 트리로 풀었을 때의 비교

|                 세그먼트 트리(메모리 / 속도)                 |                   펜윅 트리(메모리 / 속도)                   |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/17bdbc73-d7cb-4e5d-85a4-06f15b145c15) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/70bc4d78-fa08-428f-8f4f-68efc944bbce) |

풀이 결과 세그먼트 트리보다 펜윅 트리가 메모리, 속도 면에서 더 우수한 결과를 보였다.

N의 값이 작기 때문에 수치가 작아서 차이는 미미하지만 메모리 상으로도 효율적이고, 속도면에서도 불필요한 재귀 탐색을 하지 않으니 더 효율적이었다.
