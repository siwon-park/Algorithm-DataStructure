# 희소 배열 (Sparse Table)

## 1. 희소 배열

희소 배열이란 특정 구간에 대한 쿼리 연산을 빠르게 하기 위한 자료구조로, 다이나믹 프로그래밍의 원리에 기반하여 특정 길이(일반적으로 2 ^ k)의 구간의 값(최솟값, 최댓값, 합 등)을 저장한다.

그 후 쿼리에 대해서 희소 배열에 기록된 값을 활용하여 쿼리별로 `O(1)`이라는 빠른 시간으로 쿼리에 대한 질의를 해결할 수 있다.

- 단, 여기서 말한 O(1)은 2 ^ k에 대한 구간 쿼리에 대한 내용이고, 아래 LCA를 희소 배열로 접근하면 부모들을 타고 올라가야 하는 시간이 있기 때문에 O(logN)의 시간이 걸린다.

단, 값을 미리 저장하고 사용하는 개념이기 때문에 속도 상에서는 이점이 있을 수도 있으나, 메모리 사용량이 증가한다는 단점이 있다.

<br>

## 2. 최소 공통 조상(LCA, Least Common Ancestor)

> 두 노드를 모두 자식으로 가지면서, 두 노드와 가장 가까운 공통 부모 노드를 말한다.

단, 어떤 노드의 자손에는 해당 노드 자신도 포함해야 한다. 즉, 자신의 자손/조상에 자기 자신을 포함해야 한다.

[콜롬비아 대학교의 강의 노트](http://www.cs.columbia.edu/~allen/S14/NOTES/trees.pdf)에도 'ancestor(조상)'의 정의를 'An ancestor of a node is any other node on the path from the node to the root(한 노드의 조상은 해당 노드에서 루트로 가능 경로에 있는 모든 노드이다)'로 제시하고 있다. 따라서 이 역시 자기 자신의 조상에 자신을 포함한다는 의미와 같다.

ICPC 대회 문제에서도 조상/자손의 개념이 등장하는 경우에도 'Remember that a node is an ancestor of itself.'라는 문구가 존재한다. 역시 마찬가지로 자신의 조상에 자신을 포함한다는 의미이다.

<br>

## 3. 희소 배열을 활용한 LCA 찾기

LCA(에서 부모를 더 빨리 찾기 위해 희소 배열이라는 개념을 적용할 수 있다.

### 기존의 재귀적인 탐색을 통한 LCA 찾기

만약 부모 배열을 만들고 DFS를 사용한 재귀 탐색으로 n1의 부모는 n2, n2의 부모는 n3, ... 이런 식으로 기록할 수는 있다.

그런데 실제 부모를 찾아야 할 때 위의 방식으로 찾게 되면 결국에는 재귀적으로 N번 올라가야 하므로, O(N)이라는 시간이 걸리게 된다.

만약에 쿼리의 개수가 M개이고, M이 충분히 크다면 O(MN)이라는 시간이 걸리기 때문에 비효율적이다.

### 희소 배열을 활용한 LCA 찾기

희소 배열을 활용한다면, 쿼리당 O(logN)의 시간으로 문제를 해결 가능하여 총 O(MlogN)의 시간으로 문제를 풀 수 있게 된다.

2차원의 부모 배열을 선언하고, n의 2 ^ k번째 부모를 `parent[n][k]`에 저장한다.

`2 ^ (k + 1) = 2 ^ k + 2 ^ k`이므로 `parent[n][k + 1] = parent[parent[n][k]][k]`가 된다.

`n의 2 ^ (k + 1)번째 부모는 n의 2 ^ k번째 부모의 2 ^ k번째 부모`라는 의미다. 

예를 들어, 아래 그림과 같이 9번 노드의 2 ^ 3번째 부모는 9번 노드의 2 ^ 2번째 부모인 5번 노드의 2 ^ 2번째 부모이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/34299e39-d425-4699-bb42-6811c711a832)

이 때, 두 노드의 깊이 차이를 이진수로 만들어 비트가 1인 곳의 2 ^ k칸을 건너 뛰면 `깊이가 같은 노드를 찾을 수 있게 된다.`

예를 들어, `k = 13`이면, 이진수로 변경하면 `1101(2)`이고 비트가 1인 곳을 2 ^ k칸 씩 건너뛰면 1칸 + 4칸 + 8칸 = 13칸으로 총 `3번`만에 찾을 수 있게 된다. (건너 뛰는 순서는 상관 없다. 몇 번 건너뛰느냐가 중요)

보다 정확하게 이 과정을 서술하자면,

- n번 노드에서 8칸을 건너뛰어 n번 노드의 3번째 부모인 n1으로 이동
- n1번 노드에서 4칸을 건너뛰어 n1번 노드의 2번째 부모 n2로 이동
- n2번 노드에서 1칸을 건너뛰어 n2번 노드의 부모인 n3로 이동

즉, n번 노드에서 계속 이동하는 것이 아니라, n번의 2 ^ k번째 부모, n번의 2 ^ k번째 부모의 2 ^ k번째 부모, ... 이런식으로 계속해서 이동하는 것이다.

깊이가 같은 상태가 되면 이제 그곳에서 찾아서 올라가 공통 부모를 찾는 것이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/5ebed7b2-088f-417e-9137-7e0c296959ab)

<br>

#### 예시

이제, 15번 노드와 6번 노드의 공통 조상을 희소 배열을 활용하여 찾아보자.

두 노드의 깊이가 다르기 때문에 깊이를 같게 만들어줘야 한다.

두 노드의 깊이 차이는 `depth[15]` - `depth[6]` = 2이다. 2를 이진수로 표현하면 `10(2)`이다.

첫번째 비트가 1이므로 2 ^ 1 = 2칸 건너뛰어야 한다.

15번 노드의 2번째 부모는 위 테이블에서 k = 1인 곳이므로 5번 노드이다.

| 깊이 차이 계산                                               | 희소 배열(부모) 이동                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/83cfc0af-1095-4b74-8d64-ab638e19c1b0) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/0a4b90d0-3b24-42d0-8a31-ef50a981338c) |

이제 5번과 6번 노드는 깊이가 같기 때문에 `희소 배열 상에서 2 ^ k번째 부모가 같다면 해당 부모는 공통 조상 노드가 된다.`

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/01aaac50-cee9-4861-8926-52ab7169a306)

이제 k가 높은 순에서 역순으로 순회하여 계속 올라오면 된다. 만약 탐색 도중 부모가 다르면 두 노드를 올린다.

(k가 건너뛰는 2 ^ k칸 수라고 했는데, 사실 상 비교하는 시점에서부터는 트리 상의 깊이(높이)는 같으니까 깊이(높이)로 봐도 무방하다.)

- 예시에서 5번 노드와 6번 노드의 k = 1일 때, 즉 2칸(= 2 ^ 1칸) 건너뛰었을 때 부모는 1이므로, 노드를 올리지 않는다.(현재 노드를 부모로 갱신하지 않는다.)
- 그 다음인 k = 0, 1칸(= 2 ^ 0칸) 건너뛰었을 때도 부모가 같기 때문에 노드를 올리지 않는다.
- k = 0까지 다 탐색하고 나서도 두 노드는 현재 각 각 5번, 6번 노드이다.
- 두 노드의 최소 공통 조상은 결국에 `parent[5][0]` 또는 `parent[6][0]`인 `2`이다.

