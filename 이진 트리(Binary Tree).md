# 06_이진 트리(Binary Tree)

>  모든 노드들이 2개의 서브 트리를 갖는 특별한 트리이며, 각 노드가 최대 2개의 노드를 가질 수 있음

이 때, 이 2개의 노드를 왼쪽 자식 노드, 오른쪽 자식 노드라고 부름

**높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h + 1개이며, 최대 개수는 2^(h+1) -1개이다.**

(단, 만약 루트노드의 높이를 1로 가정한다면 높이 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h개 이고, 최대 개수는 2^h -1개이다.)

노드의 개수가 N개인 이진 트리의 높이는 logN으로 나타낼 수 있다(최악의 경우 N의 높이를 가질 수 있다)

![image](https://user-images.githubusercontent.com/93081720/192129840-c75edbcd-428d-45b8-8418-e06d0e1b9d2d.png)



이진 트리에서 노드에 번호를 매길 때, 일반적으로 위에서 부터 좌측에서 부터 오름차순으로 매긴다.

※ 이렇게 번호를 매기는 규칙 때문에 이진 트리의 루트 노드는 보통 1로 시작한다.

- 부모 노드의 번호(P) x2 = 왼쪽 자식 노드 번호(L)
  - L = P*2
  - R = P*2 + 1 또는 R = L + 1
  - P = L//2 또는 R//2

<br>

#### ※ 이진 트리의 저장

일반적으로 트리를 저장할 때 각 정점마다 자식 정보를 저장함(필요할 경우 부모 정보도 저장)

##### 방법 1

높이가 h인 이진 트리의 최대 노드 수는 2^(h+1) -1개 이므로 크기가 2^(h+1)개인 빈 배열을 선언한다.
완전 이진 트리 특성 상 이전 계층까지의 노드는 모두 채워져 있으므로 도중에 0이 나오지는 않는다. 따라서 노드가 끊기는 순간 0이 나오는 것이므로, 깊이 우선 탐색의 종료 조건을 `if tree[v] == 0 : return`과 같이 해줘도 된다.

- 단점: 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생, 트리 중간에 새로운 노드의 삽입, 기존 노드의 삭제 등이 발생할 경우 배열의 크기 변경이 어려워 비효율적임

##### 방법 2

이진 트리는 왼쪽 자식 노드, 오른쪽 자식 노드 이렇게 2개의 자식 노드만 존재하므로 2개의 자식 배열을 선언하고, 부모 번호를 인덱스로 하여 자식 번호를 저장한다.

| **부모**        | **P** | **0** | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| --------------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **왼쪽 자식**   | **L** |       | 2    | 4    | 6    | 8    | 10   | 12   | 14   |
| **오른쪽 자식** | **R** |       | 3    | 5    | 7    | 9    | 11   | 13   | 15   |

 이때, parent 배열은 [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]이다.

```python
# 이진 트리 입력받아 저장하기 예시
T = int(input())
for t in range(1, T+1):
    E, N = map(int, input().split()) # E는 간선의 개수
    lst = list(map(int, input().split())) # lst의 짝수번째 인덱스는 부모, 홀수는 자식
    L = [0] * (E+2)
    R = [0] * (E+2)
    for i in range(E):
        p = lst[i*2]
        c = lst[i*2+1]
        if L[p]:
            R[p] = c
        else:
            L[p] = c
```



※ 조상 찾기

```python
# 5번 노드의 조상 찾기
anc = [] # 조상을 담을 배열
c = 5
while (parent[c] != 0):
    c = parent[c] # 조상을 거슬러 올라감
    anc.append(c)

print(anc) # [2, 1]
root = c # while문 마지막에 빠져나온 c가 루트임
```



### 2. 포화 이진 트리(Full Binary Tree)

리프 노드를 제외한 모든 노드가 2개의 자식 노드를 가지는 이진 트리(사실 리프 노드도 2개의 보이지 않는 트리를 갖고 있다고 가정함) => 모든 레벨에 노드가 포화 상태임. 따라서 노드의 개수는 2^(h+1) -1 개



### 3. 완전 이진 트리(Complete Binary Tree)

포화 이진 트리에서 노드 번호 1번부터 n번까지 빠짐없이 차있되(이전 높이까지의 노드는 모두 차 있되), 마지막 높이에 있는 노드는 다 차있지 않은 이진 트리. 단, 마지막 높이에 있는 노드 또한 왼쪽에서부터 차 있어야 함



### 4. 편향 이진 트리(Skewed Binary Tree)

높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향으로만 자식 노드를 가지는 이진 트리



## 6. 이진 탐색 트리(Binary Search Tree)

### 1. 정의 및 특징

탐색 작업을 효율적으로 하기 위한 트리 자료 구조

모든 원소는 서로 다른 유일한 키값를 갖는다.

왼쪽 서브트리의 키값 < 루트의 키값 < 오른쪽 서브트리의 키값

왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리(BST)임

이진 탐색 트리를 중위 순회하면 오름차순 정렬된 값을 얻을 수 있다.



### 2. 성능

일반적으로 탐색, 삽입, 삭제는 트리의 높이만큼의 시간이 걸린다. => O(h)

- 이진 트리가 균형적으로 생성되어 있는 경우: O(logn)
- 편향 이진트리의 경우(최악의 경우): O(n) (순차탐색과 동일)
