# 시간 복잡도(Time Complexity)

일반적으로 알고리즘에서 해당 알고리즘이 어떤 인풋 데이터에서 얼마나 오랜 시간이 걸리는지에 대한 고려를 한다. 이를 시간 복잡도(Time Complexity)라고 하며 `빅오(Big-O)`로 표현한다.

<br>

## 1. 빅-오(Big-O)

보통 빅-오 표기법으로 시간 복잡도를 표현할 때, `O()`를 사용하지만 사실 정확한 표기 방법은 `O(g(n))`이다.

이 때 `g(n)`은 시간 함수이다.

- f(n) ∈ O(g(n)) : n이 증가함에 따라 g(n)보다 빨리 증가하지 않는 시간 함수의 집합
- 따라서 시간 복잡도 Big-O는 **n이 커짐에 따라 g(n)보다 더 빨리 증가하지 않는다**는 의미를 가진다. (**최선, 상한치**의 의미)
- 또한 O(n)과 같은 표기에서 사실 정확하게는 O(c * n)이며, 상수 c가 일반적으로 생략되어 있다.
  - 다만, 상수 c가 매우 커서 유의미한 영향력이 있을 경우에는 반드시 함께 표기한다.

※ Ω(g(n)) : n이 커짐에 따라 적어도 g(n)보다는 더 빨리 증가한다는 의미(최악, 하한치의 의미)

![big-O](https://user-images.githubusercontent.com/93081720/159506820-ad9e66fb-21b3-4c35-9e89-31fa866f24e9.png)

위의 그래프를 통해 시간 복잡도 Big-O를 이해하고자 하면,

내가 설계한 알고리즘의 시간 복잡도가 O(N^2)이라면, N^2보다는 작은 범위에서는 시간 복잡도가 그보다 클 수도 있지만, N이 증가함에 따라 적어도 N^2보다는 더 빨리 증가하지 않는다고 볼 수 있다.

<br>

## 2. Amortized Time Complexity

> 분석 평균 시간 복잡도

일반적인 시간 복잡도는 Worst Case 시나리오에서 얼마나 가장 오래 걸리는지 계산하여 측정한다.

그러나 이와 달리 알고리즘의 평균 동작 시간을 설명하는데 있어 `Amortized Time Complexity`라는 개념을 사용한다.

단, 유의해야 할 점은 Amortized Time Complexity != 평균 시간 복잡도이다.

평균 시간 복잡도는 최악의 경우와 최고의 경우를 모두 포함하여 연산 시간을 측정했을 때, 평균을 취한 것을 의미한다.

이와는 달리 Amortized Time Complexity는 연산 순서열(operation sequence)에 따라 연산을 연속적으로 수행했을 때 걸리는 연산의 평균 시간 복잡도를 의미한다.

### 1) 예시

예를 들어 동적 배열(Dynamicy Array)가 있다고 하자.

동적 배열은 사실 크기가 일정량으로 정해져 있다가 배열이 꽉 찼을 때 더 큰 크기의 배열로 복사하는 과정을 거쳐서 동적으로 배열을 사용한다고 해서 동적 배열이라고 한다.

동적 배열에서 배열이 꽉 찼을 때 더 큰 배열로 복사하는 작업이 필요한데, 이 작업 자체는 연산 속도가 비교적 느릴 수도 있다.  `O(n)`이 걸릴 수도 있지만 그럼에도 불구하고 동적 배열에 대한 n개의 연속적인 연산에 대한 평균 시간 복잡도는 `O(1)`로 유지된다.

왜 그럴까?

- 만약 n개의 연속된 연산 중 하나가 O(n)이 걸리더라도, 이러한 연산은 비교적 매우 드물게 발생한다.
- 대신 나머지 연산은 대부분 O(1)의 시간으로 수행된다.
- 따라서 이를 전체 시간 n으로 나누면 평균 시간 복잡도인 O(1)이 걸리는 것이다.

<br>

### 2) 예시2

이진 검색 트리(Binary Search Tree; BST)에서의 연산 예시.

BST에서 일부 연산은 최악의 경우 비교적 높은 시간 복잡도를 가질 수 있지만, 전체 연산의 평균 시간 복잡도는 훨씬 낮을 수도 있다. (이는 모든 BST가 그렇다는 의미는 아니다.)

- 최악의 경우
  - BST에 순차적으로 1부터 N까지 차례대로 데이터가 삽입될 경우, 트리의 높이가 N이 될 수도 있음
  - 이 경우 삽입 연산의 최악의 시간 복잡도는 O(N)이다.
- 평균적인 경우
  - 그러나 BST에 무작위로 삽입 연산을 수행하는 경우, 트리가 균형 잡힌 상태를 유지할 수 있게 되어 평균적으로는 깊이가 logN에 가까워지게 된다.
  - 따라서 N번 삽입 연산을 수행하더라도 연산의 평균 시간 복잡도는 O(N * logN)이 되는 것이다.
  - 트리의 균형을 유지하기 위해 때로는 회전(rotate) 연산이 필요할 수도 있다.

