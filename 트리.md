# 04_Tree(트리)

## 1. 정의

비선형 구조, 계층형 자료 구조, 한 개 이상의 노드로 이루어진 유한 집합, 원소들 간 `1:N`관계인 자료 구조

상위 원소에서 하위 원소로 내려가면서 확장되는 나무(tree) 모양의 구조

※ 그래프는 N:N관계, 트리는 1:N관계이므로, 그래프가 더 포괄적임. 따라서 트리를 무방향  연결 그래프라고 함



## 2. 특징

- 트리는 **연결 컴포넌트(Conntected Component)**다.
  - 트리에 속한 임의의 정점 u, v사이에 유일한 경로가 반드시 하나만 존재함(사이클이 없기 때문)
- 트리는 **사이클(Cycle)이 없다**.
  - 따라서 트리를 순회할 때 굳이 중복을 방지하기 위해 방문 표시를 하지 않아도 된다.
- 트리는 분리될 수 있으며, 이 **분리된 집합 또한 하나의 트리이며, 서브 트리**라고 한다.
- **노드가 하나만 있더라도 트리**라고 부를 수 있다.
- 트리로 포함관계를 표현할 수 있으며, 괄호를 표현할 수도 있다.



## 3. 구조 및 용어

- **서브트리(Subtree)** : 트리에서 분리된 집합 또한 하나의 트리이다.
- **노드(Node, Vertex)** : 트리의 원소, 트리의 노드 수는 간선의 수 +1개이다. (V = N + 1)
  - **루트 노드**: 트리의 시작점이 되는 노드. 부모 노드가 없음
  - **리프 노드**(단말 노드): 트리의 제일 끝단에 있는 노드. 자식 노드가 없음
  - **형제 노드**: 같은 부모 노드의 자식 노드들
  - **조상 노드**: 한 노드에서 간선을 따라 루트 노드까지 이르는 경로에 있는 노드들
  - **자손 노드**: 서브 트리에 있는 하위 노드들
- **간선(Edge)** : 노드를 연결하는 선, 트리의 노드가 V개일 때 간선의 수는 V - 1개다.
- **차수(Indegree)** : 노드에 연결된 자식 노드의 수
  - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값을 말함
- **높이(height)** : 루트 노드에서 어떤 한 노드에 이르는 간선 수, 노드의 레벨 또는 계층
  - 루트 노드의 높이는 0
  - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값

※ 단, 트리의 높이에 대해서 정의된 부분은 없으며, 루트의 높이를 0으로 보느냐, 1로 보느냐의 차이가 존재함



## 4. 종류

### 1. 이진 트리(Binary Tree)

모든 노드들이 2개의 서브 트리를 갖는 특별한 트리이며, 각 노드가 최대 2개의 노드를 가질 수 있음

이 때, 이 2개의 노드를 왼쪽 자식 노드, 오른쪽 자식 노드라고 부름

**높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h + 1개이며, 최대 개수는 2^(h+1) -1개이다.**

(단, 만약 루트노드의 높이를 1로 가정한다면 높이 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h개 이고, 최대 개수는 2^h -1개이다.)

노드의 개수가 N개인 이진 트리의 높이는 logN으로 나타낼 수 있다(최악의 경우 N의 높이를 가질 수 있다)

![image](https://user-images.githubusercontent.com/93081720/192129840-c75edbcd-428d-45b8-8418-e06d0e1b9d2d.png)



이진 트리에서 노드에 번호를 매길 때, 일반적으로 위에서 부터 좌측에서 부터 오름차순으로 매긴다.

※ 이렇게 번호를 매기는 규칙 때문에 이진 트리의 루트 노드는 보통 1로 시작한다.

- 부모 노드의 번호(P) x2 = 왼쪽 자식 노드 번호(L)
  - L = P*2
  - R = P*2 + 1 또는 R = L + 1
  - P = L//2 또는 R//2



#### ※ 이진 트리의 저장

일반적으로 트리를 저장할 때 각 정점마다 자식 정보를 저장함(필요할 경우 부모 정보도 저장)

##### 방법 1

높이가 h인 이진 트리의 최대 노드 수는 2^(h+1) -1개 이므로 크기가 2^(h+1)개인 빈 배열을 선언한다.
완전 이진 트리 특성 상 이전 계층까지의 노드는 모두 채워져 있으므로 도중에 0이 나오지는 않는다. 따라서 노드가 끊기는 순간 0이 나오는 것이므로, 깊이 우선 탐색의 종료 조건을 `if tree[v] == 0 : return`과 같이 해줘도 된다.

- 단점: 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생, 트리 중간에 새로운 노드의 삽입, 기존 노드의 삭제 등이 발생할 경우 배열의 크기 변경이 어려워 비효율적임

##### 방법 2

이진 트리는 왼쪽 자식 노드, 오른쪽 자식 노드 이렇게 2개의 자식 노드만 존재하므로 2개의 자식 배열을 선언하고, 부모 번호를 인덱스로 하여 자식 번호를 저장한다.

| **부모**        | **P** | **0** | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| --------------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **왼쪽 자식**   | **L** |       | 2    | 4    | 6    | 8    | 10   | 12   | 14   |
| **오른쪽 자식** | **R** |       | 3    | 5    | 7    | 9    | 11   | 13   | 15   |

 이때, parent 배열은 [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]이다.

```python
# 이진 트리 입력받아 저장하기 예시
T = int(input())
for t in range(1, T+1):
    E, N = map(int, input().split()) # E는 간선의 개수
    lst = list(map(int, input().split())) # lst의 짝수번째 인덱스는 부모, 홀수는 자식
    L = [0] * (E+2)
    R = [0] * (E+2)
    for i in range(E):
        p = lst[i*2]
        c = lst[i*2+1]
        if L[p]:
            R[p] = c
        else:
            L[p] = c
```



※ 조상 찾기

```python
# 5번 노드의 조상 찾기
anc = [] # 조상을 담을 배열
c = 5
while (parent[c] != 0):
    c = parent[c] # 조상을 거슬러 올라감
    anc.append(c)

print(anc) # [2, 1]
root = c # while문 마지막에 빠져나온 c가 루트임
```



### 2. 포화 이진 트리(Full Binary Tree)

리프 노드를 제외한 모든 노드가 2개의 자식 노드를 가지는 이진 트리(사실 리프 노드도 2개의 보이지 않는 트리를 갖고 있다고 가정함) => 모든 레벨에 노드가 포화 상태임. 따라서 노드의 개수는 2^(h+1) -1 개



### 3. 완전 이진 트리(Complete Binary Tree)

포화 이진 트리에서 노드 번호 1번부터 n번까지 빠짐없이 차있되(이전 높이까지의 노드는 모두 차 있되), 마지막 높이에 있는 노드는 다 차있지 않은 이진 트리. 단, 마지막 높이에 있는 노드 또한 왼쪽에서부터 차 있어야 함



### 4. 편향 이진 트리(Skewed Binary Tree)

높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향으로만 자식 노드를 가지는 이진 트리



## 5. 순회(Traversal)

중복없이 체계적으로(빠짐없이), 트리의 각 노드를 방문하는 것.

깊이 우선 탐색(DFS)으로 순회하며, 반드시 오른쪽 자식보다 왼쪽 자식을 먼저 방문한다. 사실 상 트리의 순회는 모든 정점을 3번씩 방문하는 셈이다. (처음 들어오면서 한번, 왼쪽 아래로 나갔다가 다시 들어오면서 1번, 오른쪽 아래로 나갔다가 다시 들어오면서 1번)

트리는 실제로 무방향 그래프이지만, 탐색을 위해 부모에서 자식 방향으로 유향 형태로 저장한다.

V : 루트 노드 / L : 왼쪽 서브 트리 / R : 오른쪽 서브 트리

순회 결과를 카운트해서 루트 노드 수는 1개, 왼쪽 서브 트리의 노드 수는 l개, 오른쪽 서브 트리의 노드 수는 r개이며, 합산하면 1+l+r이고,  재귀적으로 계산하면 모든 노드의 수를 구할 수 있음

```python
def subtree_size(v):
    if v == 0:
        return 0
    l = subtree_size(L[v])
    r = subtree_size(R[v])
    return l+r+1 # 모든 노드의 개수
```



### 1. 전위 순회(Preorder) - VLR

정점에 처음 진입하면서 방문 기록

- 순회 방법: 
  1. 현재 노드를 방문 처리함
  2. 현재 노드의 왼쪽 서브 트리로 이동함
  3. 현재 노드의 오른쪽 서브 트리로 이동

![image](https://user-images.githubusercontent.com/93081720/158597757-063003da-4a06-42e8-af6f-5989c32bc7a0.png)

**[전위 순회 결과]**

![image](https://user-images.githubusercontent.com/93081720/158604456-076a2915-c5b5-4e6f-88e3-49c4a8dfdf45.png)

```python 
preorder(1) # 1 2 4 8 9 5 10 3 6 7
```



### 2. 중위 순회(Inorder) - LVR

왼쪽 자식에서 돌아오고 나서 방문 기록

- 순회 방법:
  1. 현재 노드의 왼쪽 서브 트리로 이동함
  2. 현재 노드를 방문 처리함
  3. 현재 노드의 오른쪽 서브 트리로 이동

![image](https://user-images.githubusercontent.com/93081720/158597845-52bab2d0-55c1-4482-985e-b1a1a694ed57.png)

**[중위 순회 결과]**

![image](https://user-images.githubusercontent.com/93081720/158604737-7a17b84e-f197-43ff-95f3-52eed76ceecd.png)

```python
inorder(1) # 8 4 9 2 10 5 1 6 3 7
```



### 3. 후위 순회(Postorder) - LRV

왼쪽, 오른쪽 자식에서 돌아오고 나서 방문 기록

- 순회 방법:
  1. 현재 노드의 왼쪽 서브 트리로 이동함
  2. 현재 노드의 오른쪽 서브 트리로 이동
  3. 현재 노드를 방문 처리함

![image](https://user-images.githubusercontent.com/93081720/158597951-90774e06-c355-42d0-95e7-65210c144e70.png)

**[후위 순회 결과]**

![image](https://user-images.githubusercontent.com/93081720/158604908-f37647e3-00a9-4391-b09e-4226ac5b4dec.png)

```python
postorder(1) # 8 9 4 10 5 2 6 7 3 1
```

<br>

### 다른 순회 결과를 통한 순회 조회하기

- 전위 순회와 중위 순회를 알고 있을 때, 후위 순회를 알 수 있다.
- 후위 순회와 중위 순회를 알고 있을 때, 전위 순회를 알 수 있다.
- 그러나, 전위 순회와 후위 순회를 알고 있다고 해서 올바른 중위 순회를 알아 낼 수 있음을 보장하지 않는다.

![image](https://user-images.githubusercontent.com/93081720/230100133-680d2385-5379-4a0d-b29e-c1ca734ce9a1.png)

루트와 왼쪽 서브 트리, 오른쪽 서브 트리의 위치를 이용해 재귀적으로 호출하여 순회의 결과를 찾을 수 있다.

#### 중위 순회, 전위 순회를 통해 후위 순회 찾기

![image](https://user-images.githubusercontent.com/93081720/230112430-551b1f37-4120-4b38-968e-85f0b0f05b87.png)

![image](https://user-images.githubusercontent.com/93081720/230115303-d9d8f702-870a-430d-9013-7bea10d74614.png)

<br>

#### 중위 순회, 후위 순회를 통해 전위 순회 찾기

![image](https://user-images.githubusercontent.com/93081720/230112339-b346ce4d-f8be-496f-b973-f7f0d404f0f6.png)

![image](https://user-images.githubusercontent.com/93081720/230116441-0a92c542-8b00-4494-a0b5-02cbfa50c20a.png)

<br>

## 6. 이진 탐색 트리(Binary Search Tree)

### 1. 정의 및 특징

탐색 작업을 효율적으로 하기 위한 트리 자료 구조

모든 원소는 서로 다른 유일한 키값를 갖는다.

왼쪽 서브트리의 키값 < 루트의 키값 < 오른쪽 서브트리의 키값

왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리(BST)임

이진 탐색 트리를 중위 순회하면 오름차순 정렬된 값을 얻을 수 있다.



### 2. 성능

일반적으로 탐색, 삽입, 삭제는 트리의 높이만큼의 시간이 걸린다. => O(h)

- 이진 트리가 균형적으로 생성되어 있는 경우: O(logn)
- 편향 이진트리의 경우(최악의 경우): O(n) (순차탐색과 동일)



## 7. 힙(Heap)

완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 가장 작은 노드를 찾기 위해 만든 자료 구조

### 1. 최대 힙(Max Heap)

키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리 자료 구조

부모 노드의 키 값 > 자식 노드의 키 값

루트 노드는 키 값이 가장 큰 노드



### 2. 최소 힙(Min Heap)

키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리 자료 구조

부모 노드의 키 값 < 자식 노드의 키 값

루트 노드는 키 값이 가장 작은 노드



### 3. 연산 과정

힙 연산의 기본 순서

#### [삽입]

1. 삽입할 자리(last)를 확장하고(last += 1), 확장한 자리에 삽입할 원소를 저장

2. 부모의 키 값과 크기를 비교해서 부모 노드와 자리 변경(부모 노드가 없을 때까지 또는 비교 조건(부모의 키 값이 더 커야함 또는 자식의 키 값이 더 커야함)이 일치하는 동안 계속 반복)

#### [삭제]

1. 변수에 반환할 루트 값을 저장
2. 루트에서 요소 삭제(last의 원소 삭제 후 해당 원소값을 루트에 위치 시킴)
3. (last -= 1을 하여 last를 앞으로 옮김)
4. 자식의 키 값과 비교하여 자리 변경(자식 노드 번호가 last 이하인 동안)
   1. 오른쪽 자식이 있는지 체크하고 오른쪽 자식이 있으면 값을 비교하여  비교 조건과 일치하면 오른쪽 자식의 위치로 옮김
   2. 비교 조건이 반대일 경우 break하여 더 이상 자리를 바꾸지 않도록 함
5. 반환할 루트 값을 반환



### 4. 성능

삽입과 삭제 연산: O(logn)

전체 정렬: O(nlogn)



# 8. 세그먼트 트리(Segment Tree)

## 1. 정의

구간에 대한 정보를 보관하고 있는 트리 형태의 자료 구조

<br>

## 2. 설명

전체 구간이 [0, N - 1]이라고 할 때, 즉 N개의 구간이 있을 때 이를 포화 이진 트리로 만들어서 재귀적으로 호출하여 원하는 구간에 대한 정보를 가져오거나, 빠른 시간 안에 구간의 정보를 갱신할 수 있다

| BEFORE                                                       | AFTER                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image](https://user-images.githubusercontent.com/93081720/192138731-343d624c-6ec2-44ac-9da9-8fbe7dd2c98c.png) | ![image](https://user-images.githubusercontent.com/93081720/192138738-aec9beed-f026-4fec-b06c-4988107c9f99.png) |

[사진 출처: Ries 마법의 슈퍼 마리오](https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220791986409&referrerCode=0&searchKeyword=%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%20%ED%8A%B8%EB%A6%AC)

위와 같이 이진 트리는 아니지만 N개의 구간 정보를 갖고 있는 트리가 있을 때, 이를 포화 이진 트리로 구간을 나눠서 재구성할 수 있다.

그런데 그림을 보면 알겠지만, 원래는  [0, 2]와 같이 기존 트리에 기록되어 있던 구간이었지만 이진 트리로 변환하면서 기록되어 있지 않은 구간(=하나의 노드로 표현할 수 없는 구간)에 대해서는 어떻게 값을 구할 수 있을까?

[0, 0], [1, 1], [2, 2]로 쪼개어 나누어진 구간을 더하면 된다. 이를 재귀적으로 호출하여 계산하는 것이 바로 세그먼트 트리의 핵심이다.

<br>

## 성능

### O(logN)

구간의 정보를 계산하거나, 업데이트 할 때 모두 O(logN)의 시간이 걸린다.

#### 이유

값을 갱신하고자 한다면, 리프 노드에서 출발하여 부모 노드를 갱신하고, 또 그 부모 노드의 부모 노드를 갱신하는 재귀적 호출을 계속하는데, 이진 트리의 높이가 logN이므로 O(logN)이 걸린다.

합이나 곱을 구하는 연산에서도 마찬가지로 트리의 높이만큼 재귀적 호출을 반복하므로 O(logN)의 시간이 소모된다.

<br>

## 구현

크게 구현해야 할 함수는 다음과 같음

- 생성자(세그먼트 트리의 크기와 배열을 생성)
- 초기에 세그먼트 트리를 구성하는 함수
- 구간에 대한 정보를 반환하는 함수
- 구간에 대한 정보를 갱신하는 함수
