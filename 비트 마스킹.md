# 01_비트 마스킹(Bit Masking)

`비트 마스킹(Bit Masking)`은 `비트 연산`이라고도 하며, 십진수를 이진수로 변환하여 수에 대한 계산을 빠르게 한다거나 알고리즘 문제 풀이에서 유/무, true/false 등 2가지 상태가 존재하는 것에 대해 빠른 토글링 등을 하기 위해 사용한다.

예를 들어, 문자열 `HTHTHTHHHTTHHHT`가 있다고 할 때 `H`의 개수는 몇 개인가라고 질문이 들어온다거나 i번째 문자열을 T로 바꾸라고 한다면 어떻게 할까? 만약 문자열이 한 개가 아니라 수 십개 이상이라면?

연산 자체가 그리 간단하지는 않을 것이다. 그러나 이를 H는 1, T는 0으로 간주하고 비트 연산을 적용한다면 매우 빠르게 원하는 답을 찾을 수 있다.

<br>

## 1. 비트 연산

> 기본적으로 컴퓨터는 숫자를 이진수(bit, 비트)로 다루기 때문에 아무래도 비트 연산을 사용하는 것이 컴퓨터에게 더 최적화되어 있어 연산 속도가 빠르다.
>
> 그러나 대부분의 경우에서는 유의미한 속도 차를 보여주지 않는다.

그렇다고 하더라도 우리도 영어로 알고리즘 문제를 푸는 것보다 한국말로 된 문제를 푸는 게 더 익숙한 것처럼 컴퓨터도 컴퓨터가 이해하기 편한 숫자로 소통하는 것이 더 편할 것이다.

### 사람이 비트 연산을 할 경우

- 비트 연산을 하기 위해서 십진수를 이진수로 바꿈
- `A (비트 연산자) B`: A를 B만큼 또는 B와 비트 연산을 실시
- 연산 시 자릿수가 모자라면 앞에서부터 0을 붙인 다음 자릿수를 동일하게 만들어서 연산함
  - 예) `8 & 1` => 1000과 0001에 대한 AND 비트 연산 실시 => 0 (어떠한 비트도 일치하지 않으므로 0 반환)

### 컴퓨터가 비트 연산을 할 경우

- 비트 연산을 위해 십진수를 이진수로 바꿀 필요가 없음
  - 우리에게 표현을 십진수로 해줄뿐 실제로 컴퓨터 상에서는 이진수로 저장되어 있음!
- 나머지 과정은 같음

### 알고리즘 문제 풀이에서 비트 연산을 사용할 때 주의할 점

다른 것은 크게 문제될 것이 없는데, 비트 반전 연산인 비트 `NOT(~)`연산을 할 때 주의해야 한다.

예를 들어, `6`을 NOT연산하게 되면 값이 얼마가 나올까?

`6`은 이진수로 `110`이니 비트를 반전하면 `001`이 되어 `1`이 나와야 할 것으로 예상된다.

하지만 이상하게도 값은 `-7`이 나온다.

왜 그럴까? 컴퓨터는 사실 음수를 표현할 수 없다. 따라서 `보수`의 개념을 사용하는데, `-7`이 나온 것도 보수의 개념과 관련 있다.

비트 연산을 할 때, 앞에 숫자가 없으면 그만큼 0인 비트를 붙인다고 하였다. 그럼 결국 6은 사실 이진수로 표현했을 때 `000...000110`이다. 그럼 이것을 비트 반전 연산을 하면? `111...111001`인셈이다.

인간이 6을 비트 반전 시키면 1이라고 계산하지만 컴퓨터는 그렇지 않다. 그럼 앞에 1111.....111 얘넨 어떻게 처리했을까? 왜 `~6`이 `-7`로 출력되는 걸까?

#### `~6`이 `-7`인 이유

역으로 한 번 생각해보자

- `7`의 이진표현을 구하면 `000.000111`이다.
- `7`의 `보수`를 구한다. 이는 `각 비트들을 반전` 시키는 것이다.
  - 따라서 `111...111000`이 된다.
- `보수`에 `1`을 더한다. 이는 `2의 보수`에서 음수를 나타내기 위해 사용하는 것이다.
  - 따라서 `111...111001`이 된다.
- `-7`을 64비트 체제에서 표현하면 `111...111001`이다. 그럼 이것을 다시 비트 반전 연산하면?
  - `000...000110`으로 `6`과 같다.
- 따라서 `~6`이 `-7`로 출력되는 것이다.

<br>

## 2. 비트 연산의 종류와 의미

비트 연산의 종류와 그 의미는 다음 표와 같다


| 연산자 | 표면적 의미            | 진짜 의미    | 예시   |
| :----: | ---------------------- | ------------ | ------ |
|   >>   | 오른쪽 shift 비트 연산 | 2로 i번 나눔 | A >> B |
|   <<   | 왼쪽 shift 비트 연산   | 2를 i번 곱함 | A << B |
|   &    | 비트 연산 AND          | 비트 확인    | A & B  |
|   \|   | 비트 연산 OR           | 비트 설정    | A \| B |
|   ^    | 비트 연산 XOR          | 비트 토글링  | A ^ B  |
|   ~    | 비트 연산 NOT          | 비트 반전    | ~ A    |

<br>

### 오른쪽 shift 비트 연산 `>>`

`A >> B`: A를 이진수로 변환했을 때 비트들을 오른쪽으로 B만큼 옮김

`대상 숫자를 2로 B번 나누는 것과 동일함`

```python
print(1 >> 3) # 0 # 1을 2진수로 변환하면 1이고, 이를 오른쪽으로 3칸 밀면 1이 밖으로 나가 수가 사라진다고 보면 됨. 따라서 0이 됨
print(8 >> 1) # 4 # 8은 이진수로 1000이고, 이를 오른쪽으로 한칸 밀면 0100 → 100이고 이를 십진수로 변환하면 4이다.
```

<br>

### 왼쪽 shift 비트 연산 `<<`

`A << B`: A를 이진수로 변환했을 때 비트들을 왼쪽으로 B만큼 옮김

`대상 숫자에 2를 B번 곱하는 것과 동일함`

```python
i = 8
print(1 << i) # 256 # 1을 왼쪽으로 8칸 밀어라. 100000000이 되고, 이를 십진수로 변환하면 256이다.
# 2 ^ 8과 같은 의미를 지닌다.

print(i << 1) # 16 # 8을 왼쪽으로 1칸 밀어라. 8을 이진수로 변환하면 1000이고 여기서 왼쪽으로 밀면서 뒤에 0을 한 칸 추가하면 10000이되어 십진수로 변환하면 16이다.
# 8 * 2와 같은 의미를 지닌다.
```

<br>

### AND 비트 연산 `&`

> 두 비트 다 1인 경우에만 1

같은 자리 비트끼리 연산하여 두 비트 모두 1인 경우에만 1이 됨

따라서 연산 결과 모두 불일치한다면, 그 결과는 0임. 반대로 모두 일치한다면 원래 숫자 반환

```python
print(1 & 1) # 1
print(8 & 9)  # 8
print(1011 & 1111) # 83
print(bin(1011), bin(1111)) #1111110011, 10001010111 #10자리, 11자리

# 비트 연산
# 01111110011
# 10001010111
# 00001010011 → 83
print(bin(83)) # 1010011
```

#### 비트 확인(비트 검사)

비트 AND 연산은 주로 `특정 자리의 비트가 1인지 확인`하는데 사용된다.

예) `(9 & (1 << 3)) = 8`

- 9는 1001이고, 1 << 3은 1000이므로 8이니까, 비트 AND 연산을 하게 되면 `1000`이므로 8이 출력된다.
- 따라서 만약 특정 자리 비트가 1이 아니면 0이 출력된다. `(9 & (1 << 2)) = 0`

<br>

### OR 비트 연산 `|`

> 두 비트 중 하나만 1이더라도 1

같은 자리 비트끼리 연산하여 두 비트의 값 중 하나만 1이어도 1이 됨

```python
print(1011|1111) # 2039
print(bin(1011), bin(1111)) #1111110011, 10001010111 #10자리, 11자리
# 01111110011
# 10001010111
# 11111110111 → 2039
print(bin(2039)) # 11111110111
```

#### 비트 변환(비트 설정)

비트 OR 연산은 `특정 자리의 비트를 1로 변환`하는 것에도 사용된다.

 예) `(9 | (1 << 2)) = 13`

- 9는 1001이고, 1 << 2는 0100으로 4니까, 비트 OR 연산을 하게 되면 `1101`이 되므로 13이 출력된다.

<br>

### XOR 비트 연산 `^`

> 두 비트가 서로 다를 경우에만 1

같은 자리수끼리 연산하여 두 비트의 값이 서로 다르면 1이 됨 (두 비트가 서로 같으면 0)

```python
print(1011 ^ 1111) # 1956
print(bin(1011), bin(1111)) #1111110011, 10001010111 #10자리, 11자리
# 01111110011
# 10001010111
# 11110100100 → 1956
print(bin(1956)) # 11110100100
```

#### 비트 반전

비트 XOR 연산은 `특정 자리의 비트를 반전(토글링)하는데도 사용`된다.

예) `9 ^ (1 << 3) = 1`

- 9는 1001이고, 1 << 3은 1000이니까, 비트 XOR 연산을 하면 `0001`이 되므로 1이 출력된다.
- 즉, 3번째 비트만 같은 상태이기 때문에 1에서 0으로 반전된 것이다.

예2) `15 ^ (1 << 3) = 7`

- 15는 1111이고, 1 << 3은 1000이니까, 비트 XOR 연산을 하면 `0111`이 되므로 7이 출력된다.
- 즉, 3번째 비트만 같은 상태이기 때문에 마찬가지로 1에서 0으로 반전된 것이다.

<br>

### NOT 비트 연산 `~`

> 모든 비트를 반대로 반전시킨다

비트 1은 0으로, 비트 0은 1로 반전시킨다. (`0 → 1`, `1 → 0`)

★☆ 직접 이진수로 변환한 다음 비트 반전을 시킨 결과와 컴퓨터 상에서 비트 반전 시킨 뒤 print한 숫자와는 차이가 있기 때문에 잘못된 것이 아니다. 나온 결과 그대로 사용해서 비트 연산을 하는데 사용해도 된다.

단, 비트 반전 연산 이후 십진수에 대한 연산을 한다면 문제가 생길 수도 있기 때문에 유의

#### 비트 NOT과 AND 연산의 활용 1

`6`을 `~6`으로 바꾸면 `-7`이 출력되는데, 이를 `1`로 바꿀 수 있는 방법이 있다.

비트 NOT 연산과 비트 AND 연산을 활용하면 된다. 단, 이 방법은 비트가 최대 몇 번째 자리까지 있는지 알아야만 가능하다.

```java
int num = 6;
int inverted = ~num & 0x7FFFFFFF;
System.out.println(inverted); // 1
```

다음과 같이 대상 숫자의 비트를 `NOT 연산으로 반전시킨 다음에 모든 자리가 1인 비트와 AND 연산을 하는 것`이다.

모든 자리가 1인 비트는 최대 비트 수를 알 수 있다면 쉽게 구할 수 있다.

- 최대 비트 수가 `N`이라고 할 때 `(1 << N) - 1`을 연산한 수를 이진수로 표현하면 비트가 1인 것이 N개이다.

#### 비트 NOT과 AND 연산의 활용 2 (비트 클리어)

비트 NOT 연산과 AND 연산을 활용하면 특정 자리의 비트들을 0으로 만들 수 있는 `비트 클리어`연산이 가능하다.

먼저 비트 클리어를 원하는 위치를 선택한 후,

비트 시프트 연산과 더하기(+)를 활용하여 원하는 위치의 비트를 모두 1로 만든다.

그 후, 그 값을 비트 NOT 연산을 통해 비트 반전을 시키면 원하는 위치의 값이 모두 0이 된다.

이 반전 시킨 수와 비트 AND 연산을 하게 된다면? 결국 원하는 자리의 비트만 0으로 바꿔 비트 클리어를 할 수 있게 되는 것이다.

예) 85의 2, 3, 5번 비트를 클리어하고자 할 때

- `85`는 이진수로 표현하면 `1010101`이다.
- 2, 3, 5번 비트가 `1`인 수를 만든다.
  - `(1 << 5) + (1 << 3) + (1 << 2) = 44`
  - `0101100`
- `0101100`을 비트 NOT 연산하여 비트 반전
  - `1010011`
- `1010101`과 `1010011`을 비트 AND 연산
  - 두 비트가 1일 경우에 1이 됨
  - `1010001` → 정확히 2, 3, 5번 비트가 0으로 클리어 됨
